교육용 3D 물리 시뮬레이터 - 졸업작품 보고서

================================================================================
목차
================================================================================

| 장 | 절 | 항 | 제목 | 페이지 |
|---|---|---|---|---|
| 1 | | | 작품 개요 | |
| | 1.1 | | 작품 개요 | 1 |     -9
| | | 1.1.1 | 프로젝트명 및 개발 기간 | 1 | 
| | | 1.1.2 | 프로젝트 요약 | 1 |
| | 1.2 | | 작품 선정 배경 | 2 |
| | | 1.2.1 | 교육적 필요성 | 2 |
| | | 1.2.2 | 기존 학습 방법의 한계 | 2 |
| | | 1.2.3 | 프로젝트 목표 | 3 |
| | 1.3 | | 유사 시스템 분석 | 4 |
| | | 1.3.1 | 기존 물리 시뮬레이션 도구 | 4 |
| | | 1.3.2 | 상용 야구 분석 도구 | 5 |
| | | 1.3.3 | 차별화 포인트 | 6 |
| | 1.4 | | 구현 범위 및 목표 | 8 |
| | | 1.4.1 | 구현 범위 (In-Scope) | 8 |
| | | 1.4.2 | 제외 범위 (Out-of-Scope) | 9 |
| | | 1.4.3 | 성능 목표 | 10 |
| | 1.5 | | 개발 환경 | 11 |
| | | 1.5.1 | 프론트엔드 | 11 |
| | | 1.5.2 | 백엔드 및 인프라 | 12 |
| | | 1.5.3 | 협업 도구 | 13 |
| 2 | | | 관련 기술 | |
| | 2.1 | | Three.js 및 WebGL | 14 |
| | | 2.1.1 | Three.js 개요 | 14 |
| | | 2.1.2 | WebGL 2.0 렌더링 파이프라인 | 15 |
| | | 2.1.3 | FBX 모델 로더 | 16 |
| | 2.2 | | 물리 엔진 수치 해석 | 18 |
| | | 2.2.1 | 수치 적분 방법 | 18 |
| | | 2.2.2 | 물리력 계산 | 19 |
| | | 2.2.3 | 공기 밀도 자동 계산 | 21 |
| | 2.3 | | React 상태 관리 | 23 |
| | | 2.3.1 | React Context API | 23 |
| | | 2.3.2 | Context Factory 패턴 | 25 |
| | 2.4 | | Supabase Auth 및 RLS | 26 |
| | | 2.4.1 | Supabase Authentication | 26 |
| | | 2.4.2 | Row Level Security (RLS) | 28 |
| | | 2.4.3 | Realtime API | 29 |
| | 2.5 | | TypeScript 타입 시스템 | 30 |
| | | 2.5.1 | Generic 타입 시스템 | 30 |
| | | 2.5.2 | 확장 가능한 아키텍처 | 32 |
| | 2.6 | | 시스템 아키텍처 | 34 |
| | | 2.6.1 | 클라이언트-서버 아키텍처 (BaaS) | 34 |
| | | 2.6.2 | 디렉토리 구조 | 35 |
| | | 2.6.3 | 컴포넌트 계층도 | 36 |
| | 2.7 | | 데이터베이스 설계 | 38 |
| | | 2.7.1 | ERD (Entity-Relationship Diagram) | 38 |
| | | 2.7.2 | 테이블 스키마 | 39 |
| | | 2.7.3 | RLS 정책 | 41 |
| 3 | | | 구현 내용 | |
| | 3.1 | | 물리 엔진 구현 | 43 |
| | | 3.1.1 | PhysicsEngine 클래스 설계 | 43 |
| | | 3.1.2 | 힘 계산 모듈 (forceCalculator.ts) | 44 |
| | | 3.1.3 | RK4 적분 알고리즘 (integrator.ts) | 46 |
| | | 3.1.4 | 시뮬레이터 메인 로직 (simulator.ts) | 47 |
| | | 3.1.5 | 릴리스 포인트 자동 보정 | 48 |
| | 3.2 | | 3D 렌더링 시스템 | 49 |
| | | 3.2.1 | Scene3D 컴포넌트 구조| 49 |
| | | 3.2.2 | 카메라 제어 시스템 | 50 |
| | | 3.2.3 | 3D 모델 렌더링 | 51 |
| | | 3.2.4 | 조명 및 그림자 시스템 | 53 |
| | 3.3 | | 투수 3D 모델 및 애니메이션 | 54 |
| | | 3.3.1 | 블렌더 모델 통합 | 54 |
| | | 3.3.2 | 애니메이션 시스템 | 55 |
| | | 3.3.3 | 좌완/우완 미러링 | 56 |
| | 3.4 | | 사용자 인터페이스 | 57 |
| | | 3.4.1 | 전체 레이아웃 구조 | 57 |
| | | 3.4.2 | 파라미터 입력 UI | 58 |
| | | 3.4.3 | 결과 표시 UI | 60 |
| | | 3.4.4 | 리플레이 제어 UI | 61 |
| | | 3.4.5 | 비교 모드 UI | 63 |
| | 3.5 | | 실험 저장 및 비교 모드 | 64 |
| | | 3.5.1 | Supabase 데이터베이스 연동 | 64 |
| | | 3.5.2 | 실험 저장 플로우 | 65 |
| | | 3.5.3 | 최근 실험 목록 | 66 |
| | | 3.5.4 | 실험 상세보기 모달 | 67 |
| | | 3.5.5 | 비교 컨텍스트 (ComparisonContext) | 68 |
| | 3.6 | | 그래픽 설정 및 디버그 | 69 |
| | | 3.6.1 | 그래픽 설정 패널 | 69 |
| | | 3.6.2 | 성능 모니터링 (디버그 패널) | 71 |
| | | 3.6.3 | 렌더링 최적화 기법 | 72 |
| | | 3.6.4 | 성능 측정 결과 | 73 |
| | 3.7 | | 주요 소스 코드 상세 | 74 |
| | | 3.7.1 | simulator.ts (전체 코드) | 74 |
| | | 3.7.2 | 주요 소스 코드 설명 | 75 |
| 4 | | | 테스트 및 검증 | |
| | 4.1 | | 단위 테스트 | 105 |
| | | 4.1.1 | 테스트 환경 | 105 |
| | | 4.1.2 | 공기 밀도 계산 테스트 (calculateAirDensity) | 106 |
| | | 4.1.3 | 중력 계산 테스트 (calculateGravity) | 107 |
| | | 4.1.4 | 항력 계산 테스트 (calculateDrag) | 108 |
| | | 4.1.5 | 마그누스 효과 테스트 (calculateMagnus) | 109 |
| | | 4.1.6 | 벡터 연산 함수 테스트 | 111 |
| | | 4.1.7 | 테스트 커버리지 | 112 |
| | 4.2 | | 통합 테스트 | 113 |
| | | 4.2.1 | 3D 렌더링 테스트 | 113 |
| | | 4.2.2 | 데이터베이스 연동 테스트 | 113 |
| | | 4.2.3 | UI 인터랙션 테스트 | 114 |
| | 4.3 | | 성능 테스트 | 115 |
| | | 4.3.1 | 성능 모니터링 | 115 |
| | | 4.3.2 | 메모리 최적화 | 116 |
| | | 4.3.3 | 렌더링 최적화 | 116 |
| | | 4.3.4 | 코드 최적화 | 117 |
| 5 | | | 실행 화면 | |
| | 5.1 | | 로그인 및 회원가입 | 118 |
| | | 5.1.1 | 회원가입 화면 | 118 |
| | | 5.1.2 | 로그인 화면 | 119 |
| | 5.2 | | 메인 시뮬레이터 화면 | 120 |
| | | 5.2.1 | 전체 레이아웃 | 120 |
| | | 5.2.2 | 3D 뷰어 영역 | 121 |
| | 5.3 | | 투수 3D 모델 및 애니메이션 | 122 |
| | | 5.3.1 | 우완/좌완 자동 판정 | 122 |
| | 5.4 | | 파라미터 입력 및 결과 표시 | 123 |
| | | 5.4.1 | 파라미터 입력 패널 | 123 |
| | | 5.4.2 | 결과 패널 | 124 |
| | 5.5 | | 리플레이 및 카메라 제어 | 125 |
| | | 5.5.1 | 리플레이 컨트롤 | 125 |
| | | 5.5.2 | 카메라 프리셋 버튼 | 125 |
| | 5.6 | | 비교 모드 | 126 |
| | | 5.6.1 | 비교 모드 UI | 126 |
| | | 5.5.2 | 비교 결과 화면 | 126 |
| 6 | | | 설치 및 실행 방법 | |
| | 6.1 | | 시스템 요구사항 | 127 |
| | | 6.1.1 | 하드웨어 요구사항 | 127 |
| | | 6.1.2 | 소프트웨어 요구사항 | 127 |
| | 6.2 | | 설치 방법 | 128 |
| | | 6.2.1 | 저장소 복제 | 128 |
| | | 6.2.2 | 의존성 설치 | 128 |
| | | 6.2.3 | 환경 변수 설정 | 129 |
| | 6.3 | | 실행 방법 | 129 |
| | | 6.3.1 | 개발 모드 실행 | 129 |
| | | 6.3.2 | 프로덕션 빌드 | 130 |
| | | 6.3.3 | 프로젝트 미리보기 | 131 |
| | | 6.3.4 | 온라인 배포 버전 | 131 |
| | 6.4 | | 사용 방법 | 133 |
| | | 6.4.1 | 초기 설정 | 133 |
| | | 6.4.2 | 시뮬레이션 실행 | 133 |
| | | 6.4.3 | 실험 저장 및 비교 | 134 |
| 7 | | | 결론 | |
| | 7.1 | | 프로젝트 요약 | 135 |
| | 7.2 | | 기술적 성과 | 135 |
| | | 7.2.1 | 물리 엔진 정확도 | 135 |
| | | 7.2.2 | 성능 최적화 | 136 |
| | | 7.2.3 | 확장 가능한 아키텍처 | 136 |
| | 7.3 | | 교육적 효과 | 136 |
| | | 7.3.1 | 직관적 학습 경험 | 136 |
| | | 7.3.2 | 실험 중심 학습 | 136 |
| | | 7.3.3 | 교사 활용 가능성 | 137 |
| | 7.4 | | 한계점 및 개선 방향 | 137 |
| | | 7.4.1 | 현재 한계점 | 137 |
| | | 7.4.2 | 향후 개선 방향 | 138 |
| | 7.5 | | 최종 결론 | 139 |

| 부록 | | | | |
| | I | | 작품 사진 | 140 |
| | II | | 작품 포스터 | 149 |
| | III | | 소스 코드 상세 (나머지 파일) | 198 |

================================================================================
1. 작품 개요
================================================================================

1.1 작품 개요

1.1.1 프로젝트명 및 개발 기간

프로젝트명: 교육용 3D 물리 시뮬레이터 (야구 투구 시뮬레이터)
개발 기간: 2024년 9월 ~ 2024년 11월 (3개월)
개발 인원: 1명

1.1.2 프로젝트 요약

본 프로젝트는 물리 법칙을 직관적으로 이해할 수 있도록 돕는 확장 가능한 웹 기반 3D 물리 시뮬레이터입니다. 1차 모듈로 야구 투구 시뮬레이터를 구현하였으며, 중력, 항력, 마그누스 효과 등 실제 물리 법칙을 3D 시각화로 표현합니다.

사용자는 15개의 파라미터(공 물성, 투구 조건, 환경 변수)를 직접 입력하여 실시간으로 시뮬레이션 결과를 확인할 수 있습니다. 또한 리플레이 기능, 슬로우 모션, 힘 벡터 시각화, 비교 모드 등 다양한 분석 도구를 제공하여 물리 법칙의 직관적 이해를 돕습니다.

주요 특징:
- 확장 가능한 모듈식 아키텍처 (신규 시나리오 추가 용이)
- 실시간 3D 시각화 (Three.js, WebGL 2.0)
- 정확한 물리 계산 (RK4 적분, 마그누스 효과)
- 블렌더 3D 모델 (투수 애니메이션 동기화)
- 저사양 PC 최적화 (Intel 9세대 CPU급 30fps 목표)
- 사용자 인증 및 실험 저장/비교 기능


1.2 작품 선정 배경

1.2.1 교육적 필요성

물리 법칙은 고등학교 및 대학교 교육과정에서 중요한 부분을 차지하지만, 추상적인 개념으로 인해 학습자의 이해에 어려움이 있습니다. 특히 포물선 운동, 마그누스 효과와 같은 복잡한 물리 현상은 이론만으로는 직관적인 이해가 어렵습니다.

시각화를 통한 물리 법칙의 직관적 이해는 학습 효과를 크게 높일 수 있습니다. 특히 3D 시각화는 2D 그래프나 수식보다 훨씬 직관적이며, 실시간 파라미터 조정을 통해 인과관계를 즉시 확인할 수 있습니다.

본 프로젝트는 이러한 교육적 필요성을 충족하기 위해 야구 투구라는 친숙한 소재를 선택하였으며, 중력, 항력, 마그누스 효과 등 고등학교 물리 II 수준의 법칙을 체험할 수 있도록 설계되었습니다.

1.2.2 기존 학습 방법의 한계

전통적인 물리 교육 방법은 다음과 같은 한계점을 가지고 있습니다:

(1) 이론 중심 수업의 낮은 흥미도
교과서와 칠판 위주의 수업은 학습자의 흥미를 유발하기 어렵습니다. 특히 물리 법칙은 수식으로 표현되기 때문에 수학적 배경이 부족한 학습자는 이해에 큰 어려움을 겪습니다.

(2) 실험 장비 구축의 비용 및 공간 제약
실제 물리 실험을 위해서는 고가의 장비와 넓은 공간이 필요합니다. 특히 야구 투구 실험의 경우 고속 카메라, 레이더 장비(TrackMan, Rapsodo 등)가 필요하며, 이는 일반 교육 기관에서 구축하기 어렵습니다.

(3) 안전 문제
실제 야구공(141-149g, 73.0mm)을 사용한 실험은 안전상의 위험이 있으며, 고속(30-40 m/s)으로 투구된 공은 부상을 유발할 수 있습니다.

(4) 파라미터 조정의 어려움
실제 실험에서는 중력, 공기 밀도, 공의 질량 등을 자유롭게 조정할 수 없습니다. 반면 시뮬레이터는 가상 환경에서 모든 파라미터를 자유롭게 조정할 수 있어 물리 법칙의 영향을 명확히 이해할 수 있습니다.

본 프로젝트는 이러한 한계를 극복하기 위해 웹 기반 시뮬레이터를 개발하였습니다. 별도의 장비 없이 웹 브라우저만으로 접근 가능하며, 안전하고 비용 효율적으로 물리 법칙을 체험할 수 있습니다.

1.2.3 프로젝트 목표

본 프로젝트는 다음과 같은 세 가지 목표를 가지고 개발되었습니다:

(1) 교육자를 위한 목표
- 수업 자료로 활용 가능한 직관적인 시각화 도구 제공
- 학습자의 흥미를 유발할 수 있는 인터랙티브 콘텐츠 제공
- 실험 결과를 저장하고 비교할 수 있는 분석 도구 제공

(2) 학습자를 위한 목표
- 실시간 파라미터 조정을 통한 물리 법칙의 인과관계 체험
- 3D 시각화를 통한 직관적인 이해
- 리플레이 및 슬로우 모션을 통한 상세 분석

(3) 물리 시뮬레이션 관심 사용자를 위한 목표
- 정확한 물리 계산 엔진 제공 (RK4 적분, 마그누스 효과)
- 확장 가능한 아키텍처 (신규 시나리오 추가 용이)
- 오픈소스 공개를 통한 커뮤니티 기여


1.3 유사 시스템 분석

1.3.1 기존 물리 시뮬레이션 도구

(1) PhET Interactive Simulations (콜로라도 대학교)
PhET는 HTML5 기반의 물리 시뮬레이션 플랫폼으로, 다양한 물리 법칙을 시각화하는 도구를 제공합니다. 포물선 운동, 에너지 보존 등 기초 물리 법칙을 중심으로 구성되어 있으며, 교육 현장에서 널리 사용되고 있습니다.

장점:
- 다양한 물리 법칙 커버
- 교육 현장 검증 완료
- 무료 및 오픈소스

단점:
- 2D 시각화 중심 (3D 지원 제한적)
- 고급 물리 법칙(마그누스 효과) 부재
- 확장성 제한 (신규 시나리오 추가 어려움)

(2) Physics Classroom 웹 시뮬레이터
Physics Classroom은 물리 교육 웹사이트로, 간단한 시뮬레이션 도구를 제공합니다. 주로 교과서 보조 자료로 사용되며, 기초 물리 법칙 중심입니다.

장점:
- 교과서와 연계된 설명
- 간단한 UI

단점:
- 시각화 품질 낮음
- 파라미터 조정 제한적
- 고급 기능 부재

1.3.2 상용 야구 분석 도구

(1) Rapsodo Baseball
Rapsodo는 레이더 기반의 야구 분석 장비로, 실제 투구 데이터를 측정합니다. 속도, 회전수, 궤적 등을 실시간으로 분석할 수 있으며, 프로 야구팀 및 훈련 센터에서 사용됩니다.

장점:
- 실제 데이터 측정
- 높은 정확도

단점:
- 고가 (장비 비용 약 3,000달러)
- 교육용으로 부적합 (물리 법칙 학습 목적 아님)
- 파라미터 조정 불가 (실제 환경만 측정)

(2) TrackMan Baseball
TrackMan은 도플러 레이더 기반의 야구 분석 장비로, MLB(메이저리그)에서 공식 사용하는 시스템입니다. 공의 3D 궤적, 속도, 회전축 등을 측정합니다.

장점:
- 최고 수준의 정확도
- 3D 궤적 시각화

단점:
- 매우 고가 (장비 비용 약 20,000달러 이상)
- 교육용으로 부적합
- 시뮬레이션 기능 없음 (측정만 가능)

1.3.3 차별화 포인트

본 프로젝트는 기존 시스템 대비 다음과 같은 차별화 포인트를 가지고 있습니다:

(1) 확장 가능한 모듈식 아키텍처
기존 시뮬레이터는 특정 물리 법칙에 종속된 구조로 설계되어 있어 신규 시나리오 추가가 어렵습니다. 본 프로젝트는 BaseSimulator 추상 클래스와 Generic 타입 시스템을 활용하여 높은 코드 재사용성을 제공합니다. 신규 시나리오 추가 시 약 30분 내에 기본 구조를 구축할 수 있습니다.

(2) 저사양 PC 최적화
PhET 등 기존 시뮬레이터는 성능 최적화가 제한적이며, 저사양 환경에서는 프레임 드롭이 발생합니다. 본 프로젝트는 Intel 9세대 CPU급 환경에서 30fps 이상을 목표로 설계되었으며, 다음과 같은 최적화 기법을 적용하였습니다:
- React.memo를 통한 불필요한 리렌더링 방지
- 동적 dt 조정 (공 속도에 따라 적분 간격 자동 조정)
- 입력 디바운싱 (300ms)
- 그래픽 설정 자유 조정 (DPR, 폴리곤 수, FPS)

(3) 힘 벡터 시각화
기존 시뮬레이터는 궤적만 표시하지만, 본 프로젝트는 중력, 항력, 마그누스 힘을 3D 화살표로 실시간 표시합니다. 이를 통해 학습자는 각 힘이 공의 궤적에 미치는 영향을 직관적으로 이해할 수 있습니다.

(4) 비교 모드
2개의 실험 결과를 동시에 표시하고, 계측값 차이를 테이블로 제공합니다. 이를 통해 파라미터 변화가 궤적에 미치는 영향을 명확히 비교할 수 있습니다.

(5) 블렌더 3D 모델 및 투수 애니메이션 동기화
기존 시뮬레이터는 단순한 도형으로 투수를 표현하지만, 본 프로젝트는 블렌더에서 제작한 846KB FBX 모델을 사용하며, 119프레임 투구 애니메이션을 제공합니다. 48프레임 시점에서 공이 릴리스되도록 정확히 동기화되어 있으며, 좌완/우완 자동 미러링을 지원합니다.

(6) 무료 및 웹 기반
TrackMan, Rapsodo 등 상용 도구는 고가의 비용이 필요하지만, 본 프로젝트는 무료이며 웹 브라우저만으로 접근 가능합니다. 별도의 설치나 장비 없이 즉시 사용할 수 있습니다.


1.4 구현 범위 및 목표

1.4.1 구현 범위 (In-Scope)

본 프로젝트는 다음과 같은 기능을 구현 범위로 설정하였습니다:

(1) 야구 투구 시나리오 (1차 모듈)
- 중력, 항력, 마그누스 효과를 포함한 물리 계산
- 15개 파라미터 직접 입력 UI
  공 물성 (4개): 질량, 반지름, 항력계수, 양력계수
  투구 조건 (7개): 속도, 수평각도, 수직각도, 회전 X/Y/Z, 릴리스 포인트 X/Y/Z
  환경 변수 (4개): 중력, 온도, 기압, 습도

(2) 3D 시각화 (Three.js, WebGL 2.0)
- 실시간 3D 궤적 렌더링
- 5개 카메라 프리셋 (포수 시점, 투수 시점, 측면 시점, 추적 시점, 자유 시점)
- 힘 벡터 시각화 (중력, 항력, 마그누스 힘)
- 블렌더 3D 모델 (투수 애니메이션 동기화)
- 야구장 렌더링 (마운드, 홈플레이트, 스트라이크 존)

(3) 리플레이 및 슬로우 모션
- 리플레이 컨트롤 UI (Play/Pause, 진행률 슬라이더)
- 재생 속도 조절 (0.25x, 0.5x, 1x, 2x)
- 스페이스바 일시정지/재생
- 키보드 단축키 (방향키, [], ,.)

(4) 사용자 인증 (Supabase Auth)
- 이메일/비밀번호 인증
- JWT 기반 세션 관리
- 프로필 자동 생성 (username, role)

(5) 실험 저장 및 비교 모드
- 실험 저장 (이름, 파라미터, 결과)
- 최근 실험 목록 (최신순 20개)
- 실험 불러오기 (파라미터 자동 입력)
- 비교 모드 (2개 궤적 동시 표시, 계측값 차이 표시)

(6) 힘 벡터 시각화
- 중력, 항력, 마그누스 힘을 3D 화살표로 표시
- 힘의 크기에 비례한 화살표 길이
- 힘의 방향 표시

(7) 그래픽 설정 및 디버그
- 그래픽 설정 (DPR, 폴리곤 수, FPS, 시야각, 안티앨리어싱)
- 디버그 패널 (물리 계산 시간, FPS, 메모리 사용량)
- 성능 모니터링

1.4.2 제외 범위 (Out-of-Scope)

본 프로젝트는 다음과 같은 기능을 제외 범위로 설정하였습니다:

(1) 타격 시뮬레이션
투구 후 타격 시뮬레이션은 매우 복잡한 물리 계산이 필요하며, 본 프로젝트의 범위를 벗어납니다. 타격 시뮬레이션은 향후 2차 모듈로 고려 가능합니다.

(2) 실시간 멀티플레이어
실시간 멀티플레이어 기능은 Supabase Realtime API를 활용하여 구현 가능하지만, 1차 모듈에서는 제외하였습니다. 향후 책상 중력 게임 등 협업 시나리오에서 활용 예정입니다.

(3) 모바일 앱
웹 기반 반응형 디자인을 지원하지만, 네이티브 모바일 앱은 개발하지 않았습니다. PWA(Progressive Web App) 형태로 모바일 지원을 고려할 수 있습니다.

(4) 관리자 대시보드
교사-학생 과제 관리, 학습 진행도 추적 등 관리자 기능은 Phase 4 이후로 보류되었습니다. 현재는 개인 사용자 중심의 기능만 제공합니다.

(5) 미니게임 및 리더보드
미니게임 및 리더보드 기능은 2025년 11월 5일 기준으로 폐기되었습니다. 교육 목적에 집중하기 위해 게임 요소는 제외하였습니다.

1.4.3 성능 목표

본 프로젝트는 다음과 같은 성능 목표를 설정하였습니다:

(1) 저사양 PC 30fps 이상
Intel 9세대 CPU급 환경에서 30fps 이상을 목표로 설정하였습니다. 이를 위해 다음과 같은 최적화 기법을 적용하였습니다:
- React.memo를 통한 불필요한 리렌더링 방지
- 동적 dt 조정 (공 속도에 따라 적분 간격 자동 조정)
- 입력 디바운싱 (300ms)
- 그래픽 설정 자유 조정 (DPR, 폴리곤 수, FPS)

(2) 초기 로딩 3초 미만
Vite 번들러를 활용하여 초기 로딩 시간을 최소화하였습니다. 코드 스플리팅, Tree Shaking 등을 적용하여 번들 크기를 최적화하였습니다.

(3) 시뮬레이션 계산 100ms 미만
물리 계산은 RK4 적분을 사용하지만, 평균 2.5ms 내에 완료되도록 최적화하였습니다. 테스트 결과 1.6ms ~ 4.7ms 범위에서 계산이 완료되었습니다.

(4) 모듈식 설계로 높은 코드 재사용성
BaseSimulator 추상 클래스와 Generic 타입 시스템을 활용하여 신규 시나리오 추가 시 약 30분 내에 기본 구조를 구축할 수 있습니다.


1.5 개발 환경

1.5.1 프론트엔드

프론트엔드는 다음과 같은 기술 스택으로 구성되었습니다:

(1) 언어
- TypeScript 5.2.2
  정적 타입 검사를 통한 코드 안정성 확보
  Generic 타입 시스템을 활용한 확장 가능한 아키텍처

(2) 프레임워크
- React 18.2.0
  선언적 UI 개발
  Context API를 활용한 상태 관리
- Three.js 0.158.0
  WebGL 기반 3D 렌더링
  FBX 모델 로더, 애니메이션 믹서

(3) 빌드 도구
- Vite 5.0.0
  빠른 개발 서버 (HMR)
  최적화된 프로덕션 빌드
  코드 스플리팅, Tree Shaking

(4) 상태 관리
- React Context API
  SimulationContext (파라미터, 결과, 리플레이)
  ComparisonContext (비교 모드)
  GraphicsContext (그래픽 설정)

(5) 스타일링
- styled-components 6.1.13
  CSS-in-JS
  테마 시스템 (색상, 타이포그래피, 간격)

(6) 라우팅
- React Router 6.28.0
  클라이언트 사이드 라우팅
  Protected Route (로그인 가드)

1.5.2 백엔드 및 인프라

백엔드는 BaaS(Backend as a Service) 방식으로 구축되었습니다:

(1) BaaS
- Supabase (PostgreSQL 15)
  PostgreSQL 기반 오픈소스 BaaS
  RESTful API 자동 생성
  실시간 데이터 동기화 (Realtime API)

(2) 인증
- Supabase Auth
  이메일/비밀번호 인증
  JWT 기반 세션 관리
  Auth 트리거 (프로필 자동 생성)

(3) 데이터베이스
- PostgreSQL 15
  profiles 테이블 (사용자 프로필)
  experiments 테이블 (실험 저장, JSONB)
  RLS (Row Level Security) 정책

(4) 스토리지
- Supabase Storage
  3D 모델 파일 (FBX) 저장
  이미지 파일 저장

1.5.3 협업 도구

개발 과정에서 다음과 같은 협업 도구를 사용하였습니다:

(1) 버전 관리
- Git/GitHub
  Git-flow 전략 (main, dev 브랜치)
  커밋 메시지 규칙 (Conventional Commits)

(2) 코드 에디터
- VS Code
  TypeScript 언어 서버
  ESLint, Prettier 통합
  확장 프로그램 (GitLens, React Developer Tools)

(3) 문서화
- CLAUDE.md (프로젝트 지침)
- 작업목록.md (작업 진행 상황)
- 프로젝트 설계 명세서 (설계 문서)
- 구현 결과 보고서 (구현 상세)


================================================================================
2. 관련 기술
================================================================================

2.1 Three.js 및 WebGL

2.1.1 Three.js 개요

Three.js는 WebGL을 추상화한 JavaScript 3D 그래픽 라이브러리로, 복잡한 WebGL API를 간소화하여 웹 브라우저에서 3D 그래픽을 쉽게 구현할 수 있도록 합니다. 본 프로젝트에서는 Three.js 0.158.0 버전을 사용하였으며, React 통합을 위해 다음과 같은 라이브러리를 함께 사용하였습니다:

(1) @react-three/fiber
React Three Fiber는 Three.js를 React 컴포넌트로 래핑한 라이브러리입니다. 선언적 방식으로 3D 씬을 구성할 수 있으며, React의 상태 관리 및 라이프사이클과 자연스럽게 통합됩니다.

주요 특징:
- JSX 문법으로 3D 씬 구성
- React 상태 관리 통합
- useFrame 훅으로 애니메이션 루프 제어
- 성능 최적화 (자동 렌더링 최적화)

(2) @react-three/drei
Drei는 React Three Fiber를 위한 유틸리티 컴포넌트 라이브러리입니다. 카메라 컨트롤, 조명, 헬퍼 등 자주 사용되는 기능을 컴포넌트로 제공합니다.

주요 사용 컴포넌트:
- OrbitControls: 마우스 기반 카메라 컨트롤
- Grid: 그리드 헬퍼
- Environment: 환경 조명

2.1.2 WebGL 2.0 렌더링 파이프라인

WebGL 2.0은 GPU 가속 3D 그래픽을 웹 브라우저에서 구현하기 위한 JavaScript API입니다. 본 프로젝트에서는 다음과 같은 렌더링 파이프라인을 구성하였습니다:

(1) Canvas 설정
Canvas는 3D 씬을 렌더링하는 HTML5 요소입니다. 다음과 같은 설정을 적용하였습니다:

- FOV (Field of View): 50도
  시야각을 50도로 설정하여 자연스러운 원근감을 제공합니다. 그래픽 설정 패널에서 40~75도 범위로 조정 가능합니다.

- 카메라 위치: [5, 3, 15]
  카메라 프리셋별로 다른 위치를 사용하며, 기본 위치는 (5, 3, 15)입니다.

- DPR (Device Pixel Ratio): 1.0~2.0
  픽셀 밀도를 조정하여 성능과 화질의 균형을 맞춥니다. 저사양 PC에서는 1.0, 고사양 PC에서는 2.0을 권장합니다.

(2) 조명 시스템
3D 씬의 사실감을 높이기 위해 다음과 같은 조명을 구성하였습니다:

- Ambient Light: 강도 0.4
  전역 조명으로, 모든 객체에 균일하게 적용됩니다.

- Directional Light: 강도 1.2, 위치 [0, 30, -5]
  태양광과 유사한 평행 광원으로, 그림자를 생성합니다.

- Point Light: 투수 위치에 추가 조명
  투수 모델이 어둡지 않도록 보조 조명을 제공합니다.

(3) 그림자 렌더링
그림자는 3D 씬의 사실감을 크게 향상시키지만, 성능에 영향을 미칩니다. 본 프로젝트에서는 다음과 같은 설정을 사용하였습니다:

- Shadow Map 해상도: 1024x1024
  성능과 품질의 균형을 위해 1024x1024 해상도를 사용하였습니다. 고사양 PC에서는 2048x2048도 가능하지만, 저사양 최적화를 위해 1024를 기본값으로 설정하였습니다.

- castShadow, receiveShadow
  공, 투수, 야구장 등 주요 객체에 그림자 설정을 적용하였습니다.

2.1.3 FBX 모델 로더

FBX는 Autodesk가 개발한 3D 모델 포맷으로, 블렌더에서 제작한 모델을 웹에서 사용하기 위해 FBX 형식으로 익스포트하였습니다. Three.js는 FBXLoader를 통해 FBX 파일을 로드할 수 있습니다.

(1) FBXLoader (three-stdlib)
three-stdlib은 Three.js의 확장 라이브러리로, FBXLoader를 포함한 다양한 로더를 제공합니다. 본 프로젝트에서는 다음과 같이 FBX 모델을 로드하였습니다:

코드 예시 (Pitcher3D.tsx):
```
import { FBXLoader } from 'three-stdlib'

const loader = new FBXLoader()
loader.load('/models/pitcher.fbx', (fbx) => {
  fbx.scale.set(0.01, 0.01, 0.01)
  fbx.rotation.y = Math.PI
  setModel(fbx)
})
```

(2) 블렌더 투수 3D 모델 (846KB)
블렌더에서 제작한 투수 모델은 846KB 크기로, 다음과 같은 특징을 가지고 있습니다:

- 119프레임 투구 애니메이션 (30fps, 약 3.97초)
- 폴리곤 수: 약 2000개 (저사양 최적화)
- 텍스처: 없음 (단색 머티리얼 사용)
- 본(Bone) 구조: 간단한 리깅 (팔, 다리, 몸통)

(3) AnimationMixer 동기화
AnimationMixer는 Three.js의 애니메이션 시스템으로, 모델의 애니메이션을 재생하고 제어합니다. 본 프로젝트에서는 다음과 같이 구현하였습니다:

- AnimationAction: 애니메이션 클립을 재생하는 단위
- LoopOnce 모드: 애니메이션을 한 번만 재생
- clampWhenFinished: 애니메이션 종료 시 마지막 프레임에 고정
- 48프레임 릴리스: 공 생성 시점과 동기화

주요 코드:
```
const mixer = new AnimationMixer(fbx)
const action = mixer.clipAction(fbx.animations[0])
action.setLoop(THREE.LoopOnce, 1)
action.clampWhenFinished = true
action.play()
```


2.2 물리 엔진 수치 해석

물리 엔진은 시뮬레이터의 핵심으로, 뉴턴 운동 법칙을 기반으로 공의 궤적을 계산합니다. 본 프로젝트에서는 수치 해석 기법을 활용하여 미분방정식을 풀고, 실시간으로 궤적을 생성합니다.

2.2.1 수치 적분 방법

공의 위치와 속도는 가속도를 적분하여 구할 수 있습니다. 그러나 해석적 해(Analytical Solution)를 구하기 어려운 경우, 수치 적분 방법을 사용합니다.

(1) Euler Method (1차 방법)
가장 간단한 수치 적분 방법으로, 다음과 같은 식으로 계산합니다:

x(t + dt) = x(t) + v(t) × dt
v(t + dt) = v(t) + a(t) × dt

장점:
- 계산량이 적음 (1회 평가)
- 구현이 간단함

단점:
- 오차가 크고 누적됨
- 긴 시뮬레이션에서 불안정함

(2) Runge-Kutta 4차 (RK4 방법)
RK4는 4차 정확도를 가진 수치 적분 방법으로, Euler Method보다 훨씬 정확합니다. 다음과 같은 과정으로 계산합니다:

k1 = f(t, y)
k2 = f(t + dt/2, y + k1×dt/2)
k3 = f(t + dt/2, y + k2×dt/2)
k4 = f(t + dt, y + k3×dt)
y(t + dt) = y(t) + (k1 + 2×k2 + 2×k3 + k4) × dt/6

장점:
- 매우 정확함 (4차 오차)
- 오차 누적이 적음
- 안정적임

단점:
- 계산량이 많음 (4회 평가)
- Euler Method보다 4배 느림

본 프로젝트에서는 정확도를 우선시하여 RK4 방법을 사용하였습니다. 테스트 결과 물리 계산 시간은 평균 2.5ms로, RK4를 사용해도 성능에 문제가 없음을 확인하였습니다.

2.2.2 물리력 계산

공의 운동은 세 가지 힘의 합력으로 결정됩니다: 중력, 항력, 마그누스 효과

(1) 중력 (Gravity Force)
중력은 지구가 물체를 끌어당기는 힘으로, 다음과 같이 계산됩니다:

F_gravity = m × g × [0, -1, 0]

여기서:
- m: 공의 질량 (kg), 기본값 0.145kg
- g: 중력 가속도 (m/s²), 기본값 9.81 m/s²
- [0, -1, 0]: 아래 방향 단위 벡터

중력은 환경 변수로 조정 가능하며, 달(1.62 m/s²), 화성(3.71 m/s²), 지구(9.81 m/s²), 목성(24.79 m/s²) 등 다양한 환경에서 시뮬레이션할 수 있습니다.

(2) 항력 (Drag Force)
항력은 공기 저항에 의해 발생하는 힘으로, 속도의 제곱에 비례합니다:

F_drag = -0.5 × ρ × C_d × A × |v|² × v̂

여기서:
- ρ: 공기 밀도 (kg/m³), 온도/기압/습도로부터 자동 계산
- C_d: 항력 계수 (무차원), 기본값 0.3
- A: 단면적 (m²), A = π × r²
- |v|: 속도의 크기 (m/s)
- v̂: 속도의 방향 단위 벡터

항력은 속도가 빠를수록 급격히 증가하며, 공의 속도를 감소시킵니다. 항력 계수는 공의 표면 거칠기에 따라 달라지며, 야구공의 경우 약 0.3~0.5입니다.

(3) 마그누스 효과 (Magnus Effect)
마그누스 효과는 회전하는 공이 받는 힘으로, 회전 방향에 따라 궤적이 휘어집니다:

F_magnus = 0.5 × C_L × ρ × A × |v|² × (ω × v̂)

여기서:
- C_L: 양력 계수 (무차원), 기본값 0.2
- ω: 회전 벡터 (rad/s)
- v̂: 속도 방향 단위 벡터
- ω × v̂: 외적 (회전축과 속도에 수직인 방향)

마그누스 효과는 다음과 같은 구종을 만듭니다:
- 백스핀 (ω_x > 0): 공이 떠오름 (포심 패스트볼)
- 탑스핀 (ω_x < 0): 공이 낙차 증가 (커브볼)
- 좌회전 (ω_y > 0): 공이 1루 방향으로 휘어짐 (슬라이더)
- 우회전 (ω_y < 0): 공이 3루 방향으로 휘어짐 (체인지업)

2.2.3 공기 밀도 자동 계산

공기 밀도는 온도, 기압, 습도에 따라 변합니다. 본 프로젝트에서는 이상 기체 법칙과 Magnus 공식을 사용하여 공기 밀도를 자동으로 계산합니다.

(1) 이상 기체 법칙 기반 계산
이상 기체 법칙: PV = nRT
밀도 공식: ρ = P / (R × T)

여기서:
- P: 기압 (Pa)
- R: 기체 상수 (J/(mol·K)), 건조 공기 287.05
- T: 온도 (K)

(2) 습도 보정 (Magnus 공식)
습도가 높으면 공기 중 수증기가 증가하여 밀도가 감소합니다. Magnus 공식으로 포화 수증기압을 계산하고, 실제 수증기압을 구하여 밀도를 보정합니다:

e_s = 611.2 × exp(17.67 × T_c / (T_c + 243.5))
e = (humidity / 100) × e_s
P_dry = P - e
ρ = (P_dry / (R_dry × T)) + (e / (R_vapor × T))

여기서:
- e_s: 포화 수증기압 (Pa)
- T_c: 섭씨 온도 (°C)
- e: 실제 수증기압 (Pa)
- humidity: 상대 습도 (%)
- R_dry: 건조 공기 기체 상수 (287.05 J/(mol·K))
- R_vapor: 수증기 기체 상수 (461.5 J/(mol·K))

(3) 공기 밀도 영향
공기 밀도가 증가하면:
- 항력 증가 → 공의 속도 감소
- 마그누스 효과 증가 → 궤적 변화 증가

예시:
- 해수면, 20°C, 습도 50%: ρ ≈ 1.20 kg/m³
- 고지대 (2000m), 15°C, 습도 30%: ρ ≈ 1.00 kg/m³


2.3 React 상태 관리

본 프로젝트는 React Context API를 활용하여 전역 상태를 관리합니다. Redux, MobX 등 외부 라이브러리 대신 React 내장 기능을 사용하여 의존성을 최소화하였습니다.

2.3.1 React Context API

Context API는 React 16.3에서 도입된 전역 상태 관리 기능으로, props drilling 문제를 해결합니다. 본 프로젝트에서는 다음과 같은 Context를 사용합니다:

(1) SimulationContext
시뮬레이션 관련 상태를 관리하는 Context입니다:

관리 상태:
- params: 투구 파라미터 (15개)
- result: 시뮬레이션 결과 (궤적, 계측값)
- isSimulating: 시뮬레이션 실행 중 여부
- isReplaying: 리플레이 재생 중 여부
- replayTime: 리플레이 현재 시간 (초)
- playbackSpeed: 재생 속도 (0.25x ~ 2x)
- cameraPreset: 카메라 프리셋 (catcher, pitcher, side, follow, free)
- performanceMetrics: 성능 측정 지표

주요 액션:
- setParams: 파라미터 업데이트 (깊은 병합 지원)
- runSimulation: 시뮬레이션 실행
- reset: 초기화
- setIsReplaying: 리플레이 재생/일시정지
- setReplayTime: 리플레이 시간 조정
- setPlaybackSpeed: 재생 속도 조정
- setCameraPreset: 카메라 프리셋 변경

(2) ComparisonContext
비교 모드 관련 상태를 관리하는 Context입니다:

관리 상태:
- isComparisonMode: 비교 모드 활성화 여부
- experimentA: 첫 번째 실험 데이터
- experimentB: 두 번째 실험 데이터

주요 액션:
- setComparisonMode: 비교 모드 토글
- loadExperiments: 2개 실험 불러오기
- clearComparison: 비교 모드 초기화

(3) GraphicsContext
그래픽 설정 관련 상태를 관리하는 Context입니다:

관리 상태:
- targetFps: 목표 FPS (30, 45, 60)
- dpr: Device Pixel Ratio (1.0 ~ 2.0)
- ballQuality: 공 폴리곤 수 (8, 16, 32)
- trajectoryDt: 궤적 정밀도 (0.005 ~ 0.02)
- fov: 시야각 (40 ~ 75)
- antialiasing: 안티앨리어싱 (true/false)

주요 액션:
- setGraphicsPreset: 프리셋 적용 (저사양, 중간, 고사양)
- updateSetting: 개별 설정 변경

2.3.2 Context Factory 패턴

본 프로젝트는 확장 가능한 아키텍처를 위해 Context Factory 패턴을 적용하였습니다. 이는 신규 시나리오 추가 시 Context를 쉽게 생성할 수 있도록 합니다.

구조:
- BaseSimulationContext<TParams, TResult>: Generic 타입 시스템
- 시나리오별 Context: PitchSimulationContext, GravityGameContext 등

장점:
- 코드 중복 최소화
- 타입 안전성 확보
- 신규 시나리오 추가 용이

예시 코드:
```
interface SimulationContextType<TParams, TResult> {
  params: TParams
  result: TResult | null
  isSimulating: boolean
  setParams: (params: Partial<TParams>) => void
  runSimulation: () => void
  reset: () => void
}
```


2.4 Supabase Auth 및 RLS

본 프로젝트는 백엔드 서버 없이 Supabase BaaS를 활용하여 인증 및 데이터베이스 기능을 구현하였습니다.

2.4.1 Supabase Authentication

Supabase Auth는 PostgreSQL 기반의 인증 시스템으로, 다음과 같은 기능을 제공합니다:

(1) 이메일/비밀번호 인증
사용자는 이메일과 비밀번호로 회원가입 및 로그인할 수 있습니다:

- 회원가입: supabase.auth.signUp({ email, password, data: { username, role } })
- 로그인: supabase.auth.signInWithPassword({ email, password })
- 로그아웃: supabase.auth.signOut()

(2) JWT 기반 세션 관리
Supabase는 JWT(JSON Web Token)를 사용하여 세션을 관리합니다:

- Access Token: 1시간 유효
- Refresh Token: 자동 갱신
- 클라이언트 사이드 세션 저장 (LocalStorage)

(3) Auth 트리거 (프로필 자동 생성)
회원가입 시 PostgreSQL 트리거를 사용하여 프로필을 자동으로 생성합니다:

SQL 코드:
```
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, role)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username',
    NEW.raw_user_meta_data->>'role'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

2.4.2 Row Level Security (RLS)

RLS는 PostgreSQL의 보안 기능으로, 행(Row) 수준에서 접근 제어를 수행합니다. 본 프로젝트에서는 다음과 같은 정책을 적용하였습니다:

(1) profiles 테이블 RLS 정책
```
-- 자신의 프로필만 조회 가능
CREATE POLICY "Users can view own profile"
ON profiles FOR SELECT
USING (auth.uid() = id);

-- 자신의 프로필만 수정 가능
CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
USING (auth.uid() = id);
```

(2) experiments 테이블 RLS 정책
```
-- 자신의 실험만 조회 가능
CREATE POLICY "Users can view own experiments"
ON experiments FOR SELECT
USING (auth.uid() = user_id);

-- 자신의 실험만 삽입 가능
CREATE POLICY "Users can insert own experiments"
ON experiments FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- 자신의 실험만 삭제 가능
CREATE POLICY "Users can delete own experiments"
ON experiments FOR DELETE
USING (auth.uid() = user_id);
```

RLS의 장점:
- 백엔드 서버 없이 데이터 격리
- PostgreSQL 수준에서 보안 적용
- SQL 인젝션 방지
- 코드 단순화

2.4.3 Realtime API

Supabase Realtime은 PostgreSQL 변경사항을 WebSocket으로 실시간 전송하는 기능입니다. 본 프로젝트에서는 1차 모듈에서는 사용하지 않았지만, 향후 협업 게임 시나리오(책상 중력 게임)에서 활용 예정입니다.

주요 기능:
- INSERT, UPDATE, DELETE 이벤트 구독
- 실시간 데이터 동기화
- 멀티플레이어 게임 구현 가능

예시 코드:
```
const channel = supabase
  .channel('experiments')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'experiments'
  }, (payload) => {
    console.log('Change received!', payload)
  })
  .subscribe()
```


2.5 TypeScript 타입 시스템

본 프로젝트는 TypeScript를 사용하여 타입 안전성을 확보하고, Generic 타입 시스템을 활용하여 확장 가능한 아키텍처를 구현하였습니다.

2.5.1 Generic 타입 시스템

Generic은 타입을 매개변수화하여 재사용 가능한 컴포넌트를 만드는 기법입니다. 본 프로젝트에서는 BaseSimulator 추상 클래스에 Generic을 적용하였습니다:

BaseSimulator 정의:
```
abstract class BaseSimulator<TParams, TResult> {
  protected params: TParams

  constructor(params: TParams) {
    this.params = params
  }

  abstract run(): TResult
  abstract validate(): boolean
}
```

PitchSimulator 구현:
```
class PitchSimulator extends BaseSimulator<PitchParameters, SimulationResult> {
  run(): SimulationResult {
    // 물리 계산 로직
  }

  validate(): boolean {
    // 파라미터 검증 로직
  }
}
```

장점:
- 타입 안전성: 컴파일 시점에 타입 오류 검출
- 코드 재사용: 신규 시나리오 추가 시 BaseSimulator 상속
- 확장성: TParams, TResult를 자유롭게 정의

2.5.2 확장 가능한 아키텍처

본 프로젝트는 모듈식 설계를 통해 높은 코드 재사용성을 제공합니다. 신규 시나리오 추가 시 다음과 같은 과정으로 진행됩니다:

(1) 타입 정의
```
interface GravityGameParameters {
  planets: Planet[]
  spacecraft: Spacecraft
  target: Vector3
}

interface GravityGameResult {
  trajectory: Vector3[]
  success: boolean
  fuelUsed: number
}
```

(2) Simulator 구현
```
class GravityGameSimulator extends BaseSimulator<GravityGameParameters, GravityGameResult> {
  run(): GravityGameResult {
    // 중력 계산 로직
  }
}
```

(3) UI 컴포넌트 구현
```
function GravityGameSimulator() {
  const { params, result, runSimulation } = useSimulation<GravityGameParameters, GravityGameResult>()
  // UI 렌더링
}
```



디렉토리 구조:
```
src/
├── core/           # 재사용 가능한 공통 모듈
│   ├── physics/    # BaseSimulator, PhysicsEngine
│   ├── renderer/   # Scene3D, CameraController
│   └── ui/         # ResultPanel, ReplayControls
├── scenarios/      # 시나리오별 독립 구현
│   ├── pitch/      # 야구 투구
│   └── gravity/    # 중력 게임 (미구현)
```


2.6 시스템 아키텍처

2.6.1 클라이언트-서버 아키텍처 (BaaS)

본 프로젝트는 클라이언트-서버 아키텍처를 채택하였으며, 서버는 Supabase BaaS로 구성됩니다.

계층 구조:
(1) 프레젠테이션 계층 (Presentation Layer)
- React 18.2.0 + TypeScript 5.2.2
- Three.js 0.158.0 (3D 렌더링)
- styled-components 6.1.13 (스타일링)

(2) 비즈니스 로직 계층 (Business Logic Layer)
- 클라이언트 사이드 Physics Engine
- 물리 계산 (중력, 항력, 마그누스 효과)
- RK4 수치 적분

(3) 데이터 계층 (Data Layer)
- Supabase BaaS (PostgreSQL 15)
- Supabase Auth (JWT 인증)
- RLS (Row Level Security)

특징:
- 클라이언트 중심 계산: 물리 계산 및 렌더링은 모두 클라이언트에서 처리
- 서버리스 백엔드: Node.js/Express 서버 없이 BaaS로 구현
- 저렴한 운영 비용: 서버 인프라 불필요

2.6.2 디렉토리 구조

본 프로젝트는 모듈식 디렉토리 구조로 설계되어 있습니다:

```
src/
├── core/               # 재사용 가능한 공통 모듈
│   ├── physics/        # 물리 엔진
│   │   ├── PhysicsEngine.ts
│   │   ├── forceCalculator.ts
│   │   ├── integrator.ts
│   │   └── simulator.ts
│   ├── renderer/       # 3D 렌더링
│   │   ├── Scene3D.tsx
│   │   ├── CameraController.tsx
│   │   └── Ball3D.tsx
│   └── ui/             # 핵심 UI 컴포넌트
│       ├── ResultPanel.tsx
│       ├── ReplayControls.tsx
│       └── CameraPresetButtons.tsx
├── scenarios/          # 시나리오별 독립 구현
│   └── pitch/          # 야구 투구 시나리오
│       ├── PitchSimulator.tsx
│       ├── PitchInputPanel.tsx
│       ├── Pitcher3D.tsx
│       ├── Ball3D.tsx
│       ├── TrajectoryLine.tsx
│       └── Field.tsx
├── components/         # 공통 UI 컴포넌트
│   └── common/         # 재사용 컴포넌트
│       ├── Button.tsx
│       ├── Input.tsx
│       ├── Card.tsx
│       ├── Section.tsx
│       └── FormField.tsx
├── styles/             # 디자인 시스템
│   ├── theme.ts        # 색상, 타이포그래피, 애니메이션
│   └── GlobalStyles.tsx
├── contexts/           # 전역 상태 관리
│   ├── SimulationContext.tsx
│   ├── ComparisonContext.tsx
│   └── GraphicsContext.tsx
├── lib/                # 외부 라이브러리 설정
│   ├── supabase.ts
│   └── supabaseApi.ts
├── pages/              # 페이지 컴포넌트
│   ├── LoginPage.tsx
│   └── SignupPage.tsx
├── types/              # 전역 타입 정의
│   └── index.ts
└── utils/              # 유틸리티 함수
    ├── recentExperiments.ts
    └── validation.ts
```

2.6.3 컴포넌트 계층도

본 프로젝트의 React 컴포넌트는 다음과 같은 계층 구조로 구성됩니다:

```
App
├── Router
│   ├── LoginPage
│   ├── SignupPage
│   └── ProtectedRoute
│       └── PitchSimulator
│           ├── TopNavigationBar
│           │   ├── BackButton
│           │   ├── HelpModal
│           │   └── AccountModal
│           ├── Scene3D (3D 렌더링)
│           │   ├── Ball3D
│           │   ├── TrajectoryLine
│           │   ├── Field
│           │   ├── Grid
│           │   ├── Pitcher3D
│           │   ├── ForceVectors3D
│           │   └── CameraController
│           └── TabContainer (우측 패널)
│               ├── PitchInputPanel (파라미터 입력)
│               │   ├── Section (공 물성)
│               │   ├── Section (투구 조건)
│               │   └── Section (환경 변수)
│               ├── ResultPanel (결과)
│               │   ├── CameraPresetButtons
│               │   ├── ReplayControls
│               │   └── ForceVectorToggle
│               ├── RecentExperimentsPanel (최근 실험)
│               │   └── ExperimentDetailModal
│               ├── ComparisonPanel (비교 모드)
│               │   ├── ExperimentSelector
│               │   └── ComparisonResultTable
│               ├── GraphicsSettingsPanel (그래픽)
│               └── DebugPanel (디버그)
```


2.7 데이터베이스 설계

2.7.1 ERD (Entity-Relationship Diagram)

본 프로젝트의 데이터베이스는 다음과 같은 ERD로 구성됩니다:

엔티티:
(1) profiles (사용자 프로필)
- id: UUID (PK, auth.users.id 참조)
- username: TEXT (사용자명, UNIQUE)
- role: TEXT (역할: 'student' 또는 'teacher')
- created_at: TIMESTAMP (생성 시각)

(2) experiments (실험 데이터)
- id: UUID (PK, 자동 생성)
- user_id: UUID (FK, profiles.id 참조)
- scenario: TEXT (시나리오 이름, 예: 'pitch')
- name: TEXT (실험 이름)
- data: JSONB (파라미터 및 결과, JSON 형식)
- created_at: TIMESTAMP (생성 시각)
- updated_at: TIMESTAMP (수정 시각)

관계:
- profiles (1) --- (N) experiments
  한 사용자는 여러 실험을 가질 수 있음

2.7.2 테이블 스키마

(1) profiles 테이블
```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('student', 'teacher')),
  created_at TIMESTAMP DEFAULT NOW()
);
```

(2) experiments 테이블
```sql
CREATE TABLE experiments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  scenario TEXT NOT NULL,
  name TEXT NOT NULL,
  data JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_experiments_user_id ON experiments(user_id);
CREATE INDEX idx_experiments_created_at ON experiments(created_at DESC);
```

data JSONB 구조 예시:
```json
{
  "params": {
    "ball": {
      "mass": 0.145,
      "radius": 0.0365,
      "dragCoefficient": 0.3,
      "liftCoefficient": 0.2
    },
    "initial": {
      "velocity": 35,
      "angle": { "horizontal": 0, "vertical": -2 },
      "spin": { "x": 0, "y": 2000, "z": 0 },
      "releasePoint": { "x": 0, "y": 2.0, "z": 0 }
    },
    "environment": {
      "gravity": 9.81,
      "temperature": 20,
      "pressure": 101325,
      "humidity": 50
    }
  },
  "result": {
    "trajectory": [...],
    "flightTime": 0.527,
    "maxHeight": 2.05,
    "horizontalBreak": 0.12,
    "verticalDrop": 0.68,
    "finalVelocity": 32.5,
    "plateHeight": 0.85,
    "isStrike": true
  }
}
```

2.7.3 RLS 정책

본 프로젝트는 Row Level Security(RLS)를 활성화하여 데이터 격리를 구현하였습니다.

(1) profiles 테이블 RLS
```sql
-- RLS 활성화
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 자신의 프로필만 조회 가능
CREATE POLICY "Users can view own profile"
ON profiles FOR SELECT
USING (auth.uid() = id);

-- 자신의 프로필만 수정 가능
CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
USING (auth.uid() = id);
```

(2) experiments 테이블 RLS
```sql
-- RLS 활성화
ALTER TABLE experiments ENABLE ROW LEVEL SECURITY;

-- 자신의 실험만 조회 가능
CREATE POLICY "Users can view own experiments"
ON experiments FOR SELECT
USING (auth.uid() = user_id);

-- 자신의 실험만 삽입 가능
CREATE POLICY "Users can insert own experiments"
ON experiments FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- 자신의 실험만 삭제 가능
CREATE POLICY "Users can delete own experiments"
ON experiments FOR DELETE
USING (auth.uid() = user_id);
```

RLS 정책의 동작 방식:
- 모든 SQL 쿼리에 자동으로 WHERE 조건 추가
- PostgreSQL 수준에서 보안 적용
- 클라이언트에서 우회 불가능
- auth.uid() 함수로 현재 로그인 사용자 식별



================================================================================
3. 구현 내용
================================================================================

3.1 물리 엔진 구현

물리 엔진은 본 프로젝트의 핵심으로, 야구공의 궤적을 정확하게 계산하는 역할을 담당합니다. 뉴턴 운동 법칙을 기반으로 중력, 항력, 마그누스 효과를 계산하고, 수치 적분을 통해 공의 위치와 속도를 업데이트합니다.

3.1.1 PhysicsEngine 클래스 설계

PhysicsEngine은 물리 계산의 핵심 클래스로, 다음과 같은 구조로 설계되었습니다:

클래스 다이어그램:
PhysicsEngine
├── forceCalculator: ForceCalculator
├── integrator: Integrator
├── state: PhysicsState
└── params: PhysicsParameters

주요 메서드:
- calculateForces(): 힘 계산 (중력, 항력, 마그누스)
- integrate(): 수치 적분 (Euler 또는 RK4)
- step(): 한 스텝 진행 (힘 계산 + 적분)
- checkTermination(): 종료 조건 확인

설계 특징:
- 모듈화: forceCalculator, integrator를 별도 모듈로 분리
- 확장성: 신규 힘 추가 시 forceCalculator만 수정
- 재사용성: 다른 시나리오에서도 PhysicsEngine 재사용 가능

3.1.2 힘 계산 모듈 (forceCalculator.ts)

forceCalculator는 공에 작용하는 세 가지 힘을 계산합니다:

(1) 중력 계산
중력은 지구가 물체를 끌어당기는 힘으로, 항상 아래 방향입니다:

함수 시그니처:
function calculateGravity(mass: number, gravity: number): Vector3

계산 공식:
F_gravity = m × g × [0, -1, 0]

구현 예시:
return {
  x: 0,
  y: -mass * gravity,
  z: 0
}

(2) 항력 계산
항력은 공기 저항에 의해 발생하는 힘으로, 속도의 반대 방향입니다:

함수 시그니처:
function calculateDrag(
  velocity: Vector3,
  airDensity: number,
  dragCoef: number,
  crossSectionalArea: number
): Vector3

계산 공식:
F_drag = -0.5 × ρ × C_d × A × |v|² × v̂

구현 단계:
1. 속도 크기 계산: |v| = sqrt(vx² + vy² + vz²)
2. 속도 방향 단위 벡터: v̂ = v / |v|
3. 항력 크기 계산: |F_drag| = 0.5 × ρ × C_d × A × |v|²
4. 항력 벡터: F_drag = -|F_drag| × v̂

(3) 마그누스 효과 계산
마그누스 효과는 회전하는 공이 받는 양력으로, 회전축과 속도에 수직인 방향입니다:

함수 시그니처:
function calculateMagnus(
  velocity: Vector3,
  spin: Vector3,
  airDensity: number,
  liftCoef: number,
  crossSectionalArea: number
): Vector3

계산 공식:
F_magnus = 0.5 × C_L × ρ × A × |v|² × (ω × v̂)

구현 단계:
1. 속도 크기 및 방향 계산
2. 외적 계산: ω × v̂ (회전축과 속도에 수직)
3. 마그누스 힘 크기: |F_magnus| = 0.5 × C_L × ρ × A × |v|²
4. 마그누스 힘 벡터: F_magnus = |F_magnus| × (ω × v̂)

외적 계산 (Cross Product):
cross(a, b) = {
  x: a.y * b.z - a.z * b.y,
  y: a.z * b.x - a.x * b.z,
  z: a.x * b.y - a.y * b.x
}

3.1.3 RK4 적분 알고리즘 (integrator.ts)

Runge-Kutta 4차 (RK4) 방법은 미분방정식을 수치적으로 푸는 정확한 방법입니다. 본 프로젝트에서는 RK4를 사용하여 공의 위치와 속도를 업데이트합니다.

RK4 알고리즘:
k1 = f(t, y)
k2 = f(t + dt/2, y + k1×dt/2)
k3 = f(t + dt/2, y + k2×dt/2)
k4 = f(t + dt, y + k3×dt)
y_next = y + (k1 + 2×k2 + 2×k3 + k4) × dt/6

구현 단계:
1. k1 계산: 현재 상태에서 가속도 계산
2. k2 계산: t + dt/2 시점의 중간 상태에서 가속도 계산
3. k3 계산: k2를 이용한 중간 상태에서 가속도 계산
4. k4 계산: t + dt 시점의 끝 상태에서 가속도 계산
5. 가중 평균: (k1 + 2×k2 + 2×k3 + k4) / 6
6. 위치 및 속도 업데이트

장점:
- 4차 정확도 (오차: O(dt⁵))
- 안정적임
- 긴 시뮬레이션에서도 정확함

단점:
- 계산량 많음 (4회 평가)
- Euler보다 4배 느림

성능 측정 결과:
- 평균 계산 시간: 2.5ms
- RK4 사용해도 성능 문제 없음

3.1.4 시뮬레이터 메인 로직 (simulator.ts)

simulator.ts는 물리 엔진의 메인 루프를 담당합니다. 다음과 같은 흐름으로 동작합니다:

시뮬레이션 루프:
1. 초기 상태 설정 (위치, 속도, 회전)
2. while (not terminated):
   a. 힘 계산 (중력 + 항력 + 마그누스)
   b. 가속도 계산 (F = ma → a = F/m)
   c. RK4 적분 (위치, 속도 업데이트)
   d. 궤적 기록 (trajectory.push({position, velocity, time}))
   e. 종료 조건 확인 (홈플레이트 도달 또는 지면 충돌)
3. 결과 분석 (비행시간, 최고높이, 스트라이크 판정 등)
4. return result

주요 코드 구조:
class PitchSimulator {
  private params: PitchParameters
  private trajectory: TrajectoryPoint[] = []

  run(): SimulationResult {
    this.initialize()

    while (!this.isTerminated()) {
      const forces = this.calculateForces()
      const acceleration = this.calculateAcceleration(forces)
      this.integrate(acceleration)
      this.recordTrajectory()
    }

    return this.analyzeResult()
  }
}

종료 조건:
- 홈플레이트 도달: z ≤ -18.44m
- 지면 충돌: y ≤ 0m
- 최대 시간 초과: t > 10초 (안전장치)

3.1.5 릴리스 포인트 자동 보정

릴리스 포인트 자동 보정은 우완/좌완 투수가 홈플레이트 중심을 향해 투구하도록 각도를 자동으로 조정하는 기능입니다.

문제 상황:
- 우완 투수 (X > 0): 공이 1루 방향으로 빗나감
- 좌완 투수 (X < 0): 공이 3루 방향으로 빗나감
- 사용자 입력 horizontal angle만으로는 보정 불가

해결 방법:
1. 자연스러운 각도 계산:
deltaX = 0 - releasePoint.x  // 홈플레이트 중심까지 X 거리
deltaZ = -18.44 - releasePoint.z  // 홈플레이트까지 Z 거리
naturalAngle = atan2(deltaX, -deltaZ)  // 라디안

2. 사용자 입력 각도 더하기:
totalHorizontalAngle = naturalAngle + userInputAngle

3. 속도 벡터 계산:
vx = velocity * sin(totalHorizontalAngle) * cos(verticalAngle)
vy = velocity * sin(verticalAngle)
vz = velocity * cos(totalHorizontalAngle) * cos(verticalAngle)

효과:
- 우완/좌완 모두 자연스럽게 홈플레이트 중심 지향
- 사용자는 미세 조정만 입력하면 됨
- 실제 야구와 유사한 투구 경험

스트라이크 존 접촉 판정:
- 기존: 공 중심만 체크 → 경계 걸친 공이 볼 판정
- 개선: 공 반지름 고려 → 접촉 시 스트라이크
isStrike = (
  |x| ≤ 0.22 + ballRadius &&
  0.5 - ballRadius ≤ y ≤ 1.1 + ballRadius
)


3.2 3D 렌더링 시스템

3D 렌더링 시스템은 Three.js 라이브러리를 기반으로 구현되었으며, 사용자에게 몰입감 있는 시각적 경험을 제공하기 위해 설계되었습니다.

3.2.1 Scene3D 컴포넌트 구조

Scene3D는 Three.js Canvas를 관리하는 최상위 3D 렌더링 컴포넌트입니다.

주요 기능:
- WebGL 컨텍스트 초기화 및 설정
- 카메라 위치 및 시야각(FOV) 제어
- 조명 시스템 구성
- 성능 모니터링 (FPS, 렌더 시간)
- 그래픽 설정 적용 (DPR, 안티앨리어싱)

구현 예시:
Canvas 컴포넌트 설정:
- camera.position: [5, 3, 15] (초기 위치)
- camera.fov: 사용자 설정 가능 (40~75도)
- dpr: 픽셀 밀도 (1.0~2.0x)
- antialias: 안티앨리어싱 ON/OFF
- powerPreference: 'high-performance'

조명 시스템:
1. ambientLight: 전반적인 밝기 (intensity: 0.8)
2. directionalLight: 주 광원 (위치: [0, 30, -5], intensity: 1.2, 그림자 활성화)

성능 모니터링:
useFrame 훅을 사용하여 매 프레임 렌더링 시간을 측정하고, 30프레임마다 평균 FPS를 계산합니다. 이 데이터는 디버그 패널에 실시간으로 표시됩니다.

3.2.2 카메라 제어 시스템

CameraController 컴포넌트는 5개의 카메라 프리셋과 자유 조작 모드를 제공합니다.

카메라 프리셋:
1. 포수 시점 (catcher): position [0, 1.5, -17], target [0, 1.5, 0]
   - 홈플레이트 뒤에서 투수 방향을 바라보는 시점
   - 스트라이크 존 판정에 유용

2. 투수 시점 (pitcher): position [0, 2.5, 2], target [0, 1.5, -18.44]
   - 투수 뒤에서 홈플레이트를 바라보는 시점
   - 릴리스 포인트 확인에 적합

3. 측면 시점 (side): position [15, 2.5, -9.22], target [0, 1.5, -9.22]
   - 투수-포수 선에 완전히 수직인 시점
   - 수평 변화량 관찰에 최적

4. 공 추적 시점 (follow): 공의 약간 뒤쪽 위에서 따라가며 촬영
   - 동적 위치 계산: ballPosition + offset(2m 뒤, 1m 위)
   - 공을 중심으로 항상 바라봄

5. 자유 시점 (free): OrbitControls 활성화
   - 마우스 드래그로 회전, 줌 인/아웃 가능
   - 모든 각도에서 관찰 가능

부드러운 전환:
카메라 프리셋 전환 시 lerp(선형 보간)를 사용하여 부드럽게 이동합니다.

코드 예시:
camera.position.lerp(targetPosition, lerpFactor)

목표 위치 도달 판정:
distance = camera.position.distanceTo(targetPosition)
if (distance < 0.001) {
  // 이동 완료, lerp 중단 (떨림 방지)
}

3.2.3 3D 모델 렌더링

(1) 야구공 모델 (Ball3D)

구 형태의 지오메트리를 사용하여 야구공을 렌더링합니다.

파라미터:
- radius: 0.0366m (실제 야구공 반지름)
- sphereSegments: 그래픽 설정에 따라 8~32 (폴리곤 수 조절)
- color: #ffffff (기본), 비교 모드에서는 #4444ff (파랑) / #ff4444 (빨강)

최적화:
React.memo로 감싸 불필요한 리렌더링 방지. position prop이 변경될 때만 업데이트됩니다.

(2) 궤적 라인 (TrajectoryLine)

공의 비행 궤적을 3D 라인으로 시각화합니다.

구현 방식:
- Three.js Line 사용 (TubeGeometry 대비 50% 이상 성능 향상)
- BufferGeometry로 포인트 배열 전달
- LineBasicMaterial로 색상 및 두께 지정

포인트 생성:
trajectory.map(point => new Vector3(point.x, point.y, point.z))

최적화:
- 궤적 정밀도 설정 (50~200점)
- React.memo 적용
- useMemo로 geometry 메모이제이션

(3) 스트라이크 존 (StrikeZone3D)

홈플레이트 위치에 스트라이크 존을 반투명 평면으로 표시합니다.

위치: (0, 0.8, -18.44) - 홈플레이트 중심
크기: 가로 0.44m × 세로 0.6m (높이 0.5~1.1m)
색상: 빨간색 테두리 + 반투명 면 (opacity: 0.1)

3.2.4 조명 및 그림자 시스템

조명 구성:
1. AmbientLight (환경광): 전체 씬을 밝히는 기본 조명 (intensity: 0.8)
2. DirectionalLight (직선광): 태양광과 유사한 평행광 (intensity: 1.2)
   - 위치: [0, 30, -5] (투수 모델 위쪽)
   - 그림자 활성화 (shadow-mapSize: 1024×1024)

그림자 설정:
투수 3D 모델에 castShadow 속성을 추가하여 그림자를 드리우도록 설정했습니다. 지면 객체는 receiveShadow 속성으로 그림자를 받습니다.

성능 고려:
그림자 맵 해상도를 1024×1024로 제한하여 저사양 환경에서도 원활한 렌더링을 보장합니다.


3.3 투수 3D 모델 및 애니메이션

3.3.1 블렌더 모델 통합

블렌더(Blender)로 제작된 전문 3D 투수 모델을 FBX 형식으로 내보내어 프로젝트에 통합했습니다.

모델 사양:
- 파일 형식: FBX (Filmbox)
- 파일 크기: 846KB
- 폴리곤 수: 280 tris (저사양 최적화)
- 애니메이션 길이: 119프레임 (30fps 기준 3.97초)
- 본 구조: 머리, 몸통, 팔, 다리 (계층적 구조)

로딩 및 초기화:
FBXLoader (three-stdlib)를 사용하여 모델을 비동기로 로드합니다.

코드 예시:
const loader = new FBXLoader()
loader.load('/models/pitcher.fbx', (fbx) => {
  fbx.scale.set(0.01, 0.01, 0.01)  // 크기 조정
  fbx.rotation.y = Math.PI  // 180도 회전 (-Z 방향 바라보기)
  fbx.traverse((child) => {
    if (child.isMesh) {
      child.castShadow = true  // 그림자 드리우기
      child.receiveShadow = true  // 그림자 받기
    }
  })
  setModel(fbx)
})

3.3.2 애니메이션 시스템

Three.js AnimationMixer를 사용하여 투수의 투구 모션을 재생합니다.

애니메이션 설정:
- AnimationMixer: 애니메이션 재생 엔진
- AnimationAction: 개별 애니메이션 클립 제어
- LoopOnce 모드: 한 번만 재생 후 멈춤
- clampWhenFinished: true (마지막 프레임 유지)

타이밍 제어:
1. 대기 자세 (1프레임):
   - 페이지 로딩 시 1프레임에서 일시정지
   - 애니메이션 종료 후 1프레임으로 복귀

2. 재생 시작 (1프레임부터):
   action.time = 1 / 30  // 0.033초
   action.play()

3. 48프레임 릴리스:
   - 공 생성 시점
   - onReleaseFrame() 콜백 호출
   - 물리 시뮬레이션 시작

4. 119프레임 종료:
   - 자동으로 1프레임 복귀
   - 시간 기반 종료 감지: currentTime >= duration - 0.01

트리거 기반 재생:
startTrigger prop을 사용하여 중복 실행 문제를 해결했습니다.

useEffect(() => {
  if (startTrigger === 0) return  // 초기값은 무시

  // 강제로 1프레임부터 재시작
  action.reset()
  action.time = 1 / 30
  action.play()
}, [startTrigger])

3.3.3 좌완/우완 미러링

릴리스 포인트 X 좌표를 기준으로 좌완/우완을 자동 판정하여 모델을 미러링합니다.

판정 로직:
const isLeftHanded = releasePoint.x < 0

미러링 구현:
<group scale={[isLeftHanded ? -1 : 1, 1, 1]}>
  <primitive object={model} />
</group>

효과:
- 우완 (X > 0): 모델 그대로 표시
- 좌완 (X < 0): Y축 기준 미러링 (좌우 반전)
- 사용자는 별도 설정 없이 자동으로 적절한 폼 확인

3.3.4 투구 폼별 자세 판정

릴리스 포인트 Y 좌표에 따라 투구 폼을 자동 분류합니다.

분류 기준:
if (releasePoint.y >= 2.3) {
  폼 = "오버핸드"  // 머리 위에서 던짐
} else if (releasePoint.y >= 1.8) {
  폼 = "스리쿼터"  // 어깨와 머리 사이
} else if (releasePoint.y >= 1.3) {
  폼 = "사이드암"  // 어깨 높이
} else {
  폼 = "언더핸드"  // 허리 아래
}

시각적 역할:
투수 3D 모델은 실제 야구와 유사한 릴리스 포인트를 시각적으로 확인하고, 사용자가 입력한 파라미터의 타당성을 검증하는 교육 보조 자료로 활용됩니다.


3.4 사용자 인터페이스

3.4.1 전체 레이아웃 구조

시뮬레이터 메인 화면은 좌우 분할 레이아웃으로 구성됩니다.

레이아웃 구성:
- 상단 네비게이션 바 (TopNavigationBar): 48px 고정
  * 뒤로가기 버튼 (향후 시나리오 선택 화면 연결)
  * 시나리오 이름 표시 ("야구 투구 시뮬레이터")
  * 도움말 버튼
  * 사용자 메뉴 버튼

- 좌측 3D 뷰어 영역 (ViewerSection): flex: 1
  * Scene3D 컴포넌트 렌더링
  * 카메라 프리셋 버튼 (6개, 우측 상단 배치)
  * 리플레이 컨트롤 (하단 배치)
  * 3D 뷰어 테두리 글로우 효과

- 우측 컨트롤 패널 (RightPanel): 420px 고정
  * 탭 컨테이너 (TabContainer)
  * 4개 탭: 파라미터, 결과, 최근 실험, 비교

반응형 설계:
- 1200px 미만: 패널 너비 360px로 축소
- 768px 미만: 세로 레이아웃으로 전환 (향후 구현 예정)

3.4.2 파라미터 입력 UI

PitchInputPanel은 15개의 물리 파라미터를 입력받는 인터페이스를 제공합니다.

3단 구조 분류:
1. 투구 조건 (initial):
   - 초기 속도 (km/h): 100~160
   - 수평 각도 (도): -30~30
   - 수직 각도 (도): -10~10
   - 회전 X/Y/Z (rpm): -4000~4000
   - 릴리스 포인트 X/Y/Z (m)

2. 공 물성 (ball):
   - 질량 (kg): 0.140~0.150
   - 반지름 (m): 0.036~0.038
   - 항력 계수: 0.3~0.5
   - 양력 계수: 0.1~0.3

3. 환경 변수 (environment):
   - 중력 (m/s²): 9.78~9.82
   - 온도 (°C): -10~40
   - 기압 (hPa): 900~1100
   - 습도 (%): 0~100

입력 필드 구성:
각 파라미터는 FormField 컴포넌트로 구성되며, 다음 요소를 포함합니다:
- 레이블 (LabelWithTooltip): 파라미터 이름 + 물음표 아이콘
- 입력 필드 (Input 또는 SmallInput): 숫자 입력
- 툴팁 (Tooltip): 마우스 호버 시 상세 설명 표시

툴팁 내용 예시:
초기 속도:
"공의 초기 속도입니다. 속도가 빠를수록 비행 시간이 짧아지며, 항력과 마그누스 효과가 강해집니다. 일반적으로 프로 투수는 140~160 km/h를 기록합니다."

회전 X축:
"X축 회전은 백스핀/탑스핀을 의미합니다. 양수는 백스핀(공이 떠오름), 음수는 탑스핀(공이 빠르게 떨어짐)을 나타냅니다. 포심 패스트볼은 +2400rpm 정도입니다."

입력 예시 기능:
5개의 투구 폼 예시를 버튼으로 제공하여 사용자가 클릭 한 번으로 파라미터를 적용할 수 있습니다.

예시 목록:
1. 오버핸드 우완 포심: 속도 150km/h, 백스핀 2400rpm, 릴리스 (0.4, 2.4, 0.5)
2. 사이드암 우완 슬라이더: 속도 135km/h, Y축 회전 2200rpm, 릴리스 (0.6, 1.6, 0.5)
3. 좌완 슬라이더: 속도 130km/h, Y축 회전 -2200rpm, 릴리스 (-0.5, 2.2, 0.5)
4. 오버핸드 커브: 속도 110km/h, 탑스핀 -2000rpm, 릴리스 (0.3, 2.3, 0.5)
5. 체인지업: 속도 125km/h, 약한 백스핀 800rpm, 릴리스 (0.3, 2.2, 0.5)

시뮬레이션 시작 버튼:
버튼 위치: 패널 최하단
버튼 텍스트: "⚾ 시뮬레이션 시작" / "시뮬레이션 중..."
비활성화: 시뮬레이션 진행 중일 때 (isSimulating === true)

3.4.3 결과 표시 UI

ResultPanel은 시뮬레이션 완료 후 주요 결과를 카드 형태로 표시합니다.

결과 항목:
1. 판정 (스트라이크/볼):
   - 그라디언트 배경 (스트라이크: 파랑, 볼: 빨강)
   - 큰 아이콘 + 텍스트

2. 비행 시간 (초): Monospace 폰트로 숫자 강조
3. 최고 높이 (m): 궤적의 최고점 Y 좌표
4. 수평 변화 (m): 릴리스 포인트 대비 홈플레이트 X 좌표 차이
5. 수직 낙차 (m): 최고점 대비 홈플레이트 Y 좌표 차이
6. 통과 높이 (m): 홈플레이트 통과 시 Y 좌표
7. 최종 속도 (km/h): 홈플레이트 도달 시 속도

카드 스타일:
- 호버 효과: 살짝 위로 올라감 (translateY)
- 배경색: theme.colors.background.elevated
- 그림자: theme.shadows.md

빈 상태:
시뮬레이션 실행 전에는 아이콘 + 안내 텍스트를 표시합니다.

"파라미터를 입력하고 시뮬레이션을 시작하세요."

3.4.4 리플레이 제어 UI

ReplayControls는 시뮬레이션 결과를 다시 볼 수 있는 컨트롤러를 제공합니다.

구성 요소:
1. 타임라인 슬라이더:
   - HTML range input 사용
   - 그라디언트 진행 바 (시안 → 파랑)
   - 큰 Thumb (18px) + 호버 시 확대 (1.15x)
   - 실시간 시간 표시 (현재 시간 / 총 시간)

2. 재생 버튼:
   - 원형 버튼 (48px)
   - 재생 중일 때 글로우 링 효과
   - 아이콘: Play / Pause
   - 호버 시 확대 + 그라디언트 효과

3. 속도 조절 버튼:
   - 4개 옵션: 0.25x, 0.5x, 1x, 2x
   - Monospace 폰트
   - 활성 상태 글로우
   - 클릭 시 재생 속도 변경

4. 정지 버튼:
   - 리플레이 타임을 0으로 리셋
   - 투수 모델을 대기 자세(1프레임)로 복귀

애니메이션 루프:
requestAnimationFrame을 사용하여 부드러운 60fps 재생을 구현했습니다.

const animate = () => {
  const delta = (Date.now() - lastTime) / 1000
  lastTime = Date.now()

  setCurrentTime(prev => {
    const next = prev + delta * playbackSpeed
    if (next >= duration) {
      onPlayingChange(false)  // 종료 시 자동 정지
      return duration
    }
    return next
  })

  animationRef.current = requestAnimationFrame(animate)
}

키보드 단축키:
- Space: 재생/일시정지 토글
- ←/→: 0.5초 뒤로/앞으로 이동
- [/]: 속도 감소/증가
- ,/.: 이전/다음 프레임 이동
- R: 처음부터 다시 재생
- Esc: 리플레이 종료

3.4.5 비교 모드 UI

ComparisonPanel은 두 개의 실험을 선택하여 비교하는 인터페이스를 제공합니다.

실험 선택:
1. 실험 목록 로드:
   - Supabase에서 최근 20개 실험 조회
   - 로딩 중: 스피너 표시
   - 실패 시: 에러 메시지

2. 드롭다운 선택:
   - 실험 A 선택 (파랑)
   - 실험 B 선택 (빨강)
   - 각 실험의 주요 정보 미리보기 (속도, 회전, 결과)

3. 비교 시작:
   - "비교 시작" 버튼 클릭
   - 3D 뷰어에 2개 궤적 동시 표시
   - ComparisonResultTable 표시

비교 결과 표:
ComparisonResultTable은 두 실험의 결과를 나란히 비교하는 표를 제공합니다.

표 구성:
항목 | 실험 A | 실험 B | 차이 (A-B)
-----|--------|--------|------------
판정 | 스트라이크 | 볼 | -
비행시간 | 0.592초 | 0.610초 | -0.018초
최고높이 | 2.15m | 1.98m | +0.17m
수평변화 | 0.12m | -0.25m | +0.37m
수직낙차 | 1.32m | 1.05m | +0.27m
통과높이 | 0.83m | 0.93m | -0.10m

차이값 표시:
- 양수: 실험 A가 더 큼 (파란색)
- 음수: 실험 B가 더 큼 (빨간색)
- 절대값이 클수록 폰트 굵기 증가

비교 종료:
"비교 종료" 버튼을 누르면 비교 모드가 종료되고 단일 시뮬레이션 뷰로 돌아갑니다.

탭 전환 시 자동 종료:
비교 모드 활성화 상태에서 다른 탭으로 이동하면 자동으로 비교 모드가 해제됩니다.

onTabChange={(tabId) => {
  if (isComparing && tabId !== 'compare') {
    stopComparison()
  }
}}


3.5 실험 저장 및 비교 기능

3.5.1 Supabase 데이터베이스 연동

실험 데이터는 Supabase PostgreSQL 데이터베이스에 저장됩니다.

테이블 스키마 (experiments):
id: uuid (Primary Key)
user_id: uuid (Foreign Key → auth.users)
name: text (실험 이름)
params: jsonb (파라미터 전체)
result: jsonb (결과 전체)
created_at: timestamp
updated_at: timestamp

RLS (Row Level Security) 정책:
- SELECT: uid() = user_id (자신의 실험만 조회)
- INSERT: uid() = user_id (자신의 실험만 저장)
- UPDATE: uid() = user_id (자신의 실험만 수정)
- DELETE: uid() = user_id (자신의 실험만 삭제)

이를 통해 백엔드 코드 없이 사용자별 데이터 격리를 구현했습니다.

3.5.2 실험 저장 플로우

실험 저장 버튼 클릭 시:
1. SaveExperimentModal 표시
2. 사용자가 실험 이름 입력
3. supabaseExperimentsService.save() 호출
4. 성공 시: 토스트 메시지 + 최근 실험 목록 새로고침
5. 실패 시: 에러 메시지 표시

저장 데이터 구조:
{
  name: "오버핸드 포심 테스트",
  params: {
    ball: { mass: 0.145, radius: 0.0366, ... },
    initial: { velocity: 150, horizontalAngle: 0, ... },
    environment: { gravity: 9.81, temperature: 20, ... }
  },
  result: {
    trajectory: [ ... ],  // 궤적 포인트 배열
    flightTime: 0.592,
    maxHeight: 2.15,
    horizontalMovement: 0.12,
    verticalDrop: 1.32,
    finalHeight: 0.83,
    finalVelocity: 142.5,
    isStrike: true
  }
}

3.5.3 최근 실험 목록

RecentExperimentsPanel은 사용자의 최근 실험 10개를 표시합니다.

실험 카드 구성:
- 실험 이름 (볼드)
- 생성 시간 (상대 시간: "5분 전", "1시간 전")
- 주요 정보:
  * 속도: XXX km/h
  * 회전: XXX rpm (X/Y/Z)
  * 판정: 스트라이크 / 볼

카드 액션:
1. 불러오기 버튼: 해당 실험의 파라미터를 입력 패널에 자동 입력
2. 상세보기 버튼: ExperimentDetailModal 표시
3. 삭제 버튼: 확인 후 데이터베이스에서 삭제

전체 삭제:
"전체 삭제" 버튼을 누르면 사용자의 모든 실험을 일괄 삭제합니다.

3.5.4 실험 상세보기 모달

ExperimentDetailModal은 실험의 모든 파라미터와 결과를 표시합니다.

모달 구성:
1. 헤더: 실험 이름 + 생성 시간
2. 파라미터 섹션 (3단 구조):
   - 공 물성
   - 투구 조건
   - 환경 변수
3. 결과 섹션:
   - 판정 (큰 아이콘)
   - 7개 결과 항목

닫기 버튼: 오버레이 클릭 또는 X 버튼

3.5.5 비교 컨텍스트 (ComparisonContext)

ComparisonContext는 비교 모드의 전역 상태를 관리합니다.

상태:
- isComparing: boolean (비교 모드 활성화 여부)
- experimentA: SavedExperiment | null (실험 A 데이터)
- experimentB: SavedExperiment | null (실험 B 데이터)

함수:
- setExperimentA(exp): 실험 A 설정
- setExperimentB(exp): 실험 B 설정
- startComparison(): 비교 모드 시작
- stopComparison(): 비교 모드 종료 (상태 초기화)

사용 예시:
const { isComparing, experimentA, experimentB, startComparison } = useComparison()

if (isComparing) {
  return (
    <>
      <TrajectoryLine points={experimentA.result.trajectory} color="#4444ff" />
      <TrajectoryLine points={experimentB.result.trajectory} color="#ff4444" />
    </>
  )
}


3.6 그래픽 설정 및 성능 최적화

3.6.1 그래픽 설정 패널

GraphicsSettingsPanel은 사용자가 성능과 품질을 조절할 수 있는 UI를 제공합니다.

프리셋 가이드라인:
1. 저사양 (30fps, 안정적):
   - DPR: 1.0x
   - 공 품질: 8 segments
   - 궤적 정밀도: 50점
   - 시야각: 60°
   - 안티앨리어싱: OFF

2. 중간 (45fps, 균형):
   - DPR: 1.5x
   - 공 품질: 16 segments
   - 궤적 정밀도: 100점
   - 시야각: 60°
   - 안티앨리어싱: ON

3. 고사양 (60fps, 최고 품질):
   - DPR: 2.0x
   - 공 품질: 32 segments
   - 궤적 정밀도: 200점
   - 시야각: 60°
   - 안티앨리어싱: ON

자유 조정 설정:
각 설정 항목을 개별적으로 조절할 수 있습니다.

1. 목표 FPS (30~60):
   - 애니메이션 프레임 간격 조절
   - 높을수록 부드러운 애니메이션

2. 픽셀 밀도/DPR (1.0~2.0x):
   - 가장 큰 성능 영향
   - 높을수록 선명하지만 렌더링 부하 증가

3. 공 품질/폴리곤 수 (8~32):
   - 공의 구 형태 정밀도
   - 높을수록 부드러운 곡면

4. 궤적 정밀도 (50~200점):
   - 궤적 라인의 포인트 개수
   - 높을수록 정확한 곡선

5. 시야각/FOV (40~75°):
   - 카메라 시야 범위
   - 넓을수록 광각 효과

6. 안티앨리어싱 (ON/OFF):
   - 계단 현상 제거
   - ON 시 부드러운 경계선, 성능 약간 저하

실시간 적용:
그래픽 설정 변경 시 즉시 3D 씬에 반영됩니다.

3.6.2 성능 모니터링 (디버그 패널)

DebugPanel은 실시간 성능 지표를 표시합니다.

측정 지표:
1. 물리 계산:
   - 현재 계산 시간 (ms)
   - 평균 계산 시간 (ms)
   - 최대 계산 시간 (ms)
   - 궤적 포인트 수

2. 렌더링 성능:
   - FPS (Frames Per Second)
   - 렌더 시간 (ms)
   - 프레임 카운트

3. 전체 성능:
   - 총 프레임 시간 (물리 + 렌더)
   - 성능 평가: 우수 / 보통 / 저하

4. 메모리 사용량:
   - 사용 중 (MB)
   - 할당됨 (MB)
   - 제한 (MB)

성능 평가 기준:
- 우수: FPS >= 55
- 보통: 35 <= FPS < 55
- 저하: FPS < 35

콘솔 출력:
debugConfig.rendering === true일 때 브라우저 콘솔에 성능 지표를 실시간으로 출력합니다.

3.6.3 렌더링 최적화 기법

적용된 최적화 기법:
1. React.memo:
   - Ball3D, TrajectoryLine, Pitcher3D 등 순수 컴포넌트에 적용
   - props 변경 시에만 리렌더링

2. useMemo:
   - geometry, material 등 Three.js 객체 메모이제이션
   - 불필요한 객체 생성 방지

3. useCallback:
   - 이벤트 핸들러 함수 메모이제이션
   - 자식 컴포넌트 리렌더링 방지

4. 폴리곤 수 최적화:
   - 투수 모델: 280 tris (저사양 최적화)
   - 공 모델: 8~32 segments (설정 가능)
   - 궤적 라인: Line 사용 (TubeGeometry 대비 50% 성능 향상)

5. requestAnimationFrame:
   - setInterval 대신 RAF 사용
   - 브라우저 최적화 60fps 달성
   - 탭 비활성화 시 자동 중단

6. 메모리 관리:
   - useEffect cleanup 함수에서 Three.js 객체 dispose()
   - geometry.dispose(), material.dispose(), texture.dispose()
   - 메모리 누수 방지

7. 그림자 품질 제한:
   - shadow-mapSize: 1024×1024 (2048×2048 대신)
   - 성능과 품질의 균형

3.6.4 성능 측정 결과

저사양 설정 실측 (RTX 2050+ 환경):
- 물리 계산: 1.6~4.7 ms (매우 빠름)
- 애니메이션 중 렌더링: 30~45 FPS (목표 달성)
- 애니메이션 완료 후: 55~60 FPS

병목 지점:
- 궤적 라인 업데이트 + 공 이동 렌더링
- 비교 모드에서 2개 궤적 동시 표시 시 부하 증가

결론:
그래픽 설정 기능 구현으로 대부분의 성능 문제가 완화되었으나, LOD(Level of Detail) 적용 등 추가적인 최적화는 향후 과제로 보류되었습니다.


3.7 주요 소스 코드 상세

이 절에서는 프로젝트의 핵심 기능을 구현한 17개 파일의 소스 코드를 상세히 설명합니다.

3.7.1 소스 코드 목록

다음 표는 17개 핵심 파일의 역할과 작성자를 정리한 것입니다.

파일 이름                        설명                           작성자
-----------------              -------------------------      ------
simulator.ts                    물리 시뮬레이션 핵심 로직        이영호
SimulationContext.tsx           전역 상태 관리 Context          이영호
integrator.ts                   수치 적분 (Euler, RK4)         이영호
forces.ts                       힘 계산 (중력, 항력, 마그누스)    이영호
Scene3D.tsx                     Three.js 캔버스 및 기본 설정     이영호
CameraController.tsx            카메라 제어 로직                이영호
Ball3D.tsx                      야구공 3D 모델 및 궤적 렌더링     이영호
TabContainer.tsx                재사용 가능한 탭 컨테이너        구태훈
ReplayControls.tsx              리플레이 제어 UI                구태훈
ComparisonPanel.tsx             비교 모드 UI                    구태훈
PitchSimulator.tsx              시뮬레이터 메인 컴포넌트         이영호
PitchInputPanel.tsx             투구 파라미터 입력 UI           구태훈
LoginPage.tsx                   로그인 페이지                   구태훈
SignupPage.tsx                  회원가입 페이지                 구태훈
supabaseExperiments.ts          Supabase 실험 데이터 연동       이영호
vite.config.ts                  Vite 빌드 설정                  구태훈
tsconfig.json                   TypeScript 설정                 이영호


3.7.2 주요 소스 코드 설명

다음은 각 파일의 핵심 기능과 구현 방식을 설명합니다.

1. PitchSimulator 클래스 (simulator.ts)

기능:
물리 계산의 핵심 로직을 담당합니다. 사용자가 입력한 파라미터(공의 속도, 회전 등)를 바탕으로, 시간에 따른 공의 3차원 궤적을 계산하는 역할을 수행합니다.

설명:
simulate 메소드 내에서 while 루프를 통해 아주 짧은 시간 간격(dt)으로 공의 상태를 계속 업데이트합니다. 각 스텝마다 derivative 함수가 현재 공에 작용하는 총 힘(중력, 항력, 마그누스 힘)을 계산하여 가속도를 구합니다. 이 가속도를 바탕으로 4차 Runge-Kutta(RK4) 또는 Euler 수치 적분 방식을 사용하여 다음 시간 스텝의 속도와 위치를 계산합니다. 이 과정을 반복하여 전체 궤적을 생성합니다.

코드 (일부 발췌):
// src/core/physics/simulator.ts
export class PitchSimulator {
  private derivative: DerivativeFunction = (
    _position: Vector3,
    velocity: Vector3,
    _time: number
  ) => {
    const force = calculateTotalForce(velocity, this.params.initial.spin, this.params)
    const acceleration = calculateAcceleration(force, this.params.ball.mass)
    return {
      velocityDerivative: velocity,
      accelerationDerivative: acceleration
    }
  }

  simulate(): SimulationResult {
    // ...
    while (state.time < this.maxTime && state.position.y > 0) {
      const integrated = this.useRK4
        ? rk4Integrate(state.position, state.velocity, state.time, this.dt, this.derivative)
        : eulerIntegrate(state.position, state.velocity, state.time, this.dt, this.derivative)
      state.position = integrated.position
      state.velocity = integrated.velocity
      state.time += this.dt
      trajectory.push(vec3.clone(state.position))
    }
    // ...
  }
}


2. SimulationProvider 컴포넌트 (SimulationContext.tsx)

기능:
React Context API를 사용하여 시뮬레이션 관련 상태를 전역적으로 관리합니다. 시뮬레이션 파라미터, 결과 데이터, 리플레이 상태 등을 애플리케이션의 모든 컴포넌트가 공유할 수 있도록 중앙에서 제공하는 역할을 합니다.

설명:
useState 훅을 사용해 params, result 등의 상태를 정의합니다. runSimulation과 같은 상태 변경 함수를 내부에 구현하고, 이 상태들과 함수들을 SimulationContext.Provider의 value prop으로 묶어 하위 컴포넌트에 전달합니다. 하위 컴포넌트에서는 useSimulation 커스텀 훅을 호출하여 손쉽게 전역 상태에 접근하고 상태를 변경할 수 있습니다. 이를 통해 Props drilling 문제를 해결하고 컴포넌트 간의 결합도를 낮춥니다.

코드 (일부 발췌):
// src/contexts/SimulationContext.tsx
export function SimulationProvider({ children }: { children: ReactNode }): JSX.Element {
  const [params, setParamsState] = useState<PitchParameters>(DEFAULT_PARAMS)
  const [result, setResult] = useState<SimulationResult | null>(null)

  const runSim = (trajectoryDt: number = 0.01): void => {
    const simResult = runSimulation(params, { dt: trajectoryDt })
    setResult(simResult)
  }

  const value: SimulationContextType = {
    params,
    result,
    runSimulation: runSim,
    // ...
  }

  return (
    <SimulationContext.Provider value={value}>
      {children}
    </SimulationContext.Provider>
  )
}


3. PitchSimulator 리액트 컴포넌트 (PitchSimulator.tsx)

기능:
시뮬레이션의 모든 시각적 요소를 조합하고 사용자 인터랙션을 처리하는 메인 UI 컴포넌트입니다. 3D 렌더링 영역과 컨트롤 패널을 배치하고, 전역 상태에 따라 화면을 업데이트하는 역할을 합니다.

설명:
useSimulation 훅을 호출하여 SimulationContext로부터 현재 시뮬레이션 상태(result, isComparing 등)를 가져옵니다. 이 상태 값에 따라 조건부 렌더링을 수행합니다. 예를 들어, isComparing 상태가 true이면 비교 모드의 두 궤적을, false이면 현재 시뮬레이션의 궤적을 렌더링합니다. useEffect 훅을 사용하여 키보드 입력 등 사용자 이벤트를 처리하고, 상태에 따라 3D 객체의 위치를 업데이트합니다.

코드 (일부 발췌):
// src/scenarios/pitch/PitchSimulator.tsx
export function PitchSimulator() {
  const { result, cameraPreset } = useSimulation()
  const { experimentA, experimentB, isComparing } = useComparison()
  const currentPosition = result?.trajectory[currentIndex] || { x: 0, y: 2, z: 0 };

  return (
    <Container>
      <MainContent>
        <ViewerSection>
          <Scene3D cameraPreset={cameraPreset}>
            {isComparing ? (
              <>
                <TrajectoryLine points={experimentA.result.trajectory} color="#4444ff" />
                <TrajectoryLine points={experimentB.result.trajectory} color="#ff4444" />
              </>
            ) : (
              <>
                <Ball3D position={currentPosition} />
                <TrajectoryLine points={currentTrajectory} />
              </>
            )}
          </Scene3D>
        </ViewerSection>
        {/* ... */}
      </MainContent>
    </Container>
  )
}


4. 수치 적분 모듈 (integrator.ts)

기능:
시뮬레이션의 핵심 계산 방법인 수치 적분을 수행합니다. 오일러(Euler) 방법과 4차 룽게-쿠타(RK4) 방법을 제공하여, 정확도와 계산 속도 사이의 트레이드오프를 가능하게 합니다. 또한 기본적인 3D 벡터 연산 유틸리티(vec3)를 포함합니다.

설명:
eulerIntegrate 함수는 현재 상태를 기반으로 다음 스텝의 위치와 속도를 단순하게 계산하는 1차 근사 방법입니다. 반면, rk4Integrate 함수는 현재 스텝과 다음 스텝 사이의 여러 지점(k1, k2, k3, k4)에서 기울기(미분값)를 계산하고, 이들의 가중 평균을 사용하여 다음 상태를 훨씬 더 정확하게 예측하는 4차 근사 방법입니다. PitchSimulator는 이 두 함수 중 하나를 선택하여 while 루프 안에서 반복적으로 호출합니다.

코드 (일부 발췌):
// src/core/physics/integrator.ts
export function eulerIntegrate(
  // ...
): IntegrationResult {
  const { velocityDerivative, accelerationDerivative } = derivative(position, velocity, time)

  return {
    position: vec3.add(position, vec3.multiply(velocityDerivative, dt)),
    velocity: vec3.add(velocity, vec3.multiply(accelerationDerivative, dt))
  }
}

export function rk4Integrate(
  // ...
): IntegrationResult {
  // k1, k2, k3, k4 계산
  // ...
  // 가중 평균을 이용한 최종 위치 및 속도 변화량 계산
  // ...
  return {
    position: vec3.add(position, positionChange),
    velocity: vec3.add(velocity, velocityChange)
  }
}


5. 힘 계산 모듈 (forces.ts)

기능:
시뮬레이션에 필요한 다양한 물리적 힘(중력, 항력, 마그누스 힘)을 계산하는 함수들을 제공합니다. 공기 밀도 계산 함수를 포함하여, 실제와 유사한 환경에서 공의 궤적을 예측하는 데 필수적인 요소들을 구현합니다.

설명:
- calculateAirDensity: 온도, 기압, 습도를 기반으로 공기 밀도를 계산합니다. 이상 기체 법칙과 Magnus 공식을 활용하여 습한 공기의 밀도를 정확하게 추정합니다.
- calculateGravity: 공의 질량과 중력 가속도를 이용하여 중력을 계산합니다. 항상 지면 방향(Y축 음의 방향)으로 작용합니다.
- calculateDrag: 공의 속도, 공기 밀도, 공의 단면적, 항력 계수를 사용하여 항력을 계산합니다. 공의 운동 방향과 반대 방향으로 작용하여 속도를 감소시킵니다.
- calculateMagnus: 공의 속도, 회전(스핀), 공기 밀도, 공의 반지름, 양력 계수를 사용하여 마그누스 힘을 계산합니다. 공의 회전축과 속도 벡터의 외적 방향으로 작용하여 공의 궤적을 휘게 만듭니다.
- calculateTotalForce: 위에서 계산된 중력, 항력, 마그누스 힘을 모두 합산하여 공에 작용하는 총 힘을 구합니다.
- calculateAcceleration: 총 힘과 공의 질량을 이용하여 뉴턴의 제2법칙(F=ma)에 따라 가속도를 계산합니다.

코드 (일부 발췌):
// src/core/physics/forces.ts
export function calculateAirDensity(
  temp: number,
  pressure: number,
  humidity: number
): number {
  const T = temp + 273.15
  const p = pressure * 100
  const R_specific = 287.05
  const e_s = 611.2 * Math.exp(17.67 * temp / (temp + 243.5))
  const e = (humidity / 100) * e_s
  const rho = (p / (R_specific * T)) * (1 - 0.378 * e / p)
  return rho
}

export function calculateGravity(mass: number, gravity: number): Vector3 {
  return vec3.create(0, -mass * gravity, 0)
}

export function calculateDrag(
  velocity: Vector3,
  params: PitchParameters,
  airDensity: number
): Vector3 {
  const speed = vec3.length(velocity)
  if (speed === 0) return vec3.create(0, 0, 0)

  const velocityDirection = vec3.normalize(velocity)
  const area = Math.PI * params.ball.radius * params.ball.radius
  const dragMagnitude = 0.5 * airDensity * params.ball.dragCoefficient * area * speed * speed
  return vec3.multiply(velocityDirection, -dragMagnitude)
}

export function calculateMagnus(
  velocity: Vector3,
  spin: Vector3,
  params: PitchParameters,
  airDensity: number
): Vector3 {
  const speed = vec3.length(velocity)
  if (speed === 0) return vec3.create(0, 0, 0)

  const spinMagnitude = vec3.length(spin)
  if (spinMagnitude === 0) return vec3.create(0, 0, 0)

  const spinRadPerSec = spinMagnitude * (2 * Math.PI) / 60
  const spinAxis = vec3.normalize(spin)
  const velocityDirection = vec3.normalize(velocity)
  const forceDirection = vec3.cross(spinAxis, velocityDirection)
  const area = Math.PI * params.ball.radius * params.ball.radius
  const magnusMagnitude = 0.5 * params.ball.liftCoefficient * airDensity * area * speed * (params.ball.radius * spinRadPerSec)

  return vec3.multiply(forceDirection, magnusMagnitude)
}

export function calculateTotalForce(
  velocity: Vector3,
  spin: Vector3,
  params: PitchParameters
): Vector3 {
  const airDensity = calculateAirDensity(
    params.environment.temperature,
    params.environment.pressure,
    params.environment.humidity
  )

  const gravity = calculateGravity(params.ball.mass, params.environment.gravity)
  const drag = calculateDrag(velocity, params, airDensity)
  const magnus = calculateMagnus(velocity, spin, params, airDensity)

  return vec3.add(vec3.add(gravity, drag), magnus)
}

export function calculateAcceleration(
  force: Vector3,
  mass: number
): Vector3 {
  return vec3.divide(force, mass)
}


6. 메인 3D 씬 컴포넌트 (Scene3D.tsx)

기능:
Three.js 캔버스를 설정하고, 3D 씬의 기본 환경(카메라, 조명)을 구성하며, 렌더링 성능을 모니터링하는 핵심 컴포넌트입니다. 모든 3D 객체는 이 컴포넌트 내에서 렌더링됩니다.

설명:
- Canvas 컴포넌트: @react-three/fiber 라이브러리의 Canvas를 사용하여 Three.js 렌더링 컨텍스트를 초기화합니다. 카메라 위치, 시야각(FOV), 배경색, DPR(Device Pixel Ratio), WebGL 설정(안티앨리어싱, 성능 선호도) 등을 정의합니다.
- PerformanceMonitor 컴포넌트: useFrame 훅을 활용하여 매 프레임 렌더링 시간을 측정하고, 약 1초마다 평균 FPS와 렌더링 시간을 계산하여 SimulationContext에 업데이트합니다. 이는 디버깅 및 성능 최적화에 활용됩니다.
- 조명 설정: ambientLight로 전반적인 분위기를 밝히고, directionalLight를 추가하여 그림자를 드리우는 주 광원으로 사용합니다. shadow-mapSize를 설정하여 그림자 품질을 제어합니다.
- 카메라 컨트롤: cameraPreset이 free일 경우 @react-three/drei의 OrbitControls를 활성화하여 사용자가 마우스로 씬을 자유롭게 탐색할 수 있도록 합니다.
- children 렌더링: Scene3D 컴포넌트의 자식으로 전달되는 모든 React 요소를 3D 씬 내부에 렌더링하여 유연하게 3D 객체를 추가할 수 있도록 합니다.

코드 (일부 발췌):
// src/core/renderer/Scene3D.tsx
import { Canvas, useFrame } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'

function PerformanceMonitor() {
  const { updatePerformanceMetrics, performanceMetrics } = useSimulation()
  const frameCountRef = useRef(0)
  const lastTimeRef = useRef(performance.now())
  const renderTimesRef = useRef<number[]>([])

  useFrame(() => {
    const now = performance.now()
    const renderTime = now - lastTimeRef.current
    lastTimeRef.current = now

    frameCountRef.current++
    renderTimesRef.current.push(renderTime)

    if (frameCountRef.current % 30 === 0) {
      const avgRenderTime = renderTimesRef.current.reduce((a, b) => a + b, 0) / renderTimesRef.current.length
      const fps = 1000 / avgRenderTime

      const newMetrics = {
        renderTime: avgRenderTime,
        fps,
        frameCount: frameCountRef.current,
        totalFrameTime: (performanceMetrics?.physicsTime || 0) + avgRenderTime
      }

      updatePerformanceMetrics(newMetrics)
      renderTimesRef.current = []
    }
  })

  return null
}

export function Scene3D({ children, cameraPreset = 'free' }: Scene3DProps) {
  const { settings } = useGraphics()

  return (
    <Canvas
      camera={{
        position: [5, 3, 15],
        fov: settings.fov,
        near: 0.1,
        far: 50
      }}
      style={{ background: '#1a1a2e' }}
      dpr={[settings.dpr, settings.dpr]}
      performance={{ min: 0.5 }}
      gl={{
        antialias: settings.antialias,
        alpha: false,
        powerPreference: 'high-performance',
        stencil: false,
        depth: true
      }}
      frameloop="always"
    >
      <ambientLight intensity={0.8} />
      <directionalLight
        position={[0, 30, -5]}
        intensity={1.2}
        castShadow
        shadow-mapSize-width={1024}
        shadow-mapSize-height={1024}
      />

      {cameraPreset === 'free' && (
        <OrbitControls
          enablePan={true}
          enableZoom={true}
          enableRotate={true}
          minDistance={5}
          maxDistance={50}
          maxPolarAngle={Math.PI / 2}
        />
      )}

      <PerformanceMonitor />
      {children}
    </Canvas>
  )
}


7. 탭 컨테이너 컴포넌트 (TabContainer.tsx)

기능:
여러 개의 탭을 관리하고, 선택된 탭에 해당하는 콘텐츠를 표시하는 재사용 가능한 UI 컴포넌트입니다. 시뮬레이션 파라미터, 결과, 최근 실험 등 다양한 정보를 깔끔하게 정리하여 보여주는 데 사용됩니다.

설명:
- Tab 인터페이스: 각 탭의 id, label(표시 이름), content(렌더링될 React 요소)를 정의합니다.
- useState 훅: activeTab 상태를 관리하여 현재 활성화된 탭의 id를 저장합니다. defaultTab prop이 제공되면 해당 탭을 초기값으로 설정하고, 없으면 첫 번째 탭을 활성화합니다.
- handleTabClick 함수: 탭 버튼 클릭 시 호출되며, activeTab 상태를 업데이트하고 onTabChange 콜백 함수를 실행합니다.
- 렌더링: TabHeader에 tabs 배열을 매핑하여 각 탭 버튼을 렌더링합니다. TabButton은 activeTab 상태에 따라 시각적으로 활성화된 탭을 강조합니다. TabContent 영역에는 activeTab에 해당하는 탭의 content가 렌더링됩니다.
- 스타일링: styled-components를 사용하여 Container, TabHeader, TabButton, TabContent의 스타일을 정의합니다. theme 객체를 활용하여 일관된 디자인 시스템을 적용하며, TabButton에는 활성화 상태에 따른 색상 및 폰트 변화, 호버 효과, 그리고 은은한 글로우 효과를 구현하여 사용자 경험을 향상시킵니다. TabContent에는 스크롤 페이드 효과를 추가하여 내용이 많을 때 시각적인 부드러움을 제공합니다.

코드 (일부 발췌):
// src/core/ui/TabContainer.tsx
import { ReactNode, useState } from 'react'
import styled from 'styled-components'

export interface Tab {
  id: string
  label: string
  content: ReactNode
}

interface TabContainerProps {
  tabs: Tab[]
  defaultTab?: string
  onTabChange?: (tabId: string) => void
}

export function TabContainer({ tabs, defaultTab, onTabChange }: TabContainerProps) {
  const [activeTab, setActiveTab] = useState(defaultTab || tabs[0]?.id)

  const handleTabClick = (tabId: string) => {
    setActiveTab(tabId)
    onTabChange?.(tabId)
  }

  const currentTab = tabs.find(tab => tab.id === activeTab)

  return (
    <Container>
      <TabHeader>
        {tabs.map(tab => (
          <TabButton
            key={tab.id}
            $active={activeTab === tab.id}
            onClick={() => handleTabClick(tab.id)}
          >
            {tab.label}
          </TabButton>
        ))}
      </TabHeader>

      <TabContent>
        {currentTab?.content}
      </TabContent>
    </Container>
  )
}

const Container = styled.div`
  display: flex;
  flex-direction: column;
  height: 100%;
  background: ${theme.colors.background.secondary};
  border-radius: ${theme.borderRadius.lg};
  overflow: hidden;
  box-shadow: ${theme.shadows.lg};
  border: 1px solid ${theme.colors.border.light};
`

const TabButton = styled.button<{ $active: boolean }>`
  position: relative;
  flex: 1;
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  border: none;
  border-radius: ${theme.borderRadius.md};
  background: ${props => props.$active ? theme.colors.background.elevated : 'transparent'};
  color: ${props => props.$active ? theme.colors.primary.main : theme.colors.text.secondary};
  font-size: ${theme.typography.fontSize.sm};
  font-weight: ${props => props.$active ? theme.typography.fontWeight.semibold : theme.typography.fontWeight.regular};
  cursor: pointer;
  transition: ${theme.transitions.normal};
  overflow: hidden;

  &:hover {
    background: ${props => props.$active ? theme.colors.background.elevated : 'rgba(0, 217, 255, 0.1)'};
  }
`


8. Supabase 실험 데이터 연동 유틸리티 (supabaseExperiments.ts)

기능:
Supabase 백엔드 서비스와 연동하여 시뮬레이션 실험 데이터를 저장, 조회, 삭제하는 기능을 제공합니다. 사용자별 실험 데이터를 클라우드에 안전하게 관리할 수 있도록 돕습니다.

설명:
- supabaseExperimentsService 객체는 getAll, save, getById, delete, deleteAll, count와 같은 비동기 메서드를 포함합니다.
- 각 메서드는 @/lib/supabase에서 가져온 supabase 클라이언트 인스턴스를 사용하여 Supabase의 experiments 테이블과 상호작용합니다.
- getAll: created_at 필드를 기준으로 최신순으로 정렬하여 실험 목록을 가져옵니다. limit 파라미터로 가져올 개수를 제한할 수 있습니다.
- save: 새로운 실험 데이터를 experiments 테이블에 삽입합니다. name이 제공되지 않으면 현재 날짜와 시간을 기반으로 자동 생성됩니다. params와 result 객체는 unknown 타입으로 캐스팅되어 JSONB 형태로 저장됩니다.
- getById: 특정 id를 가진 실험 데이터를 조회합니다.
- delete: 특정 id를 가진 실험 데이터를 삭제합니다.
- deleteAll: 모든 실험 데이터를 삭제합니다.
- count: experiments 테이블의 총 실험 개수를 반환합니다.
- 모든 데이터베이스 작업은 try-catch 블록으로 감싸져 있어 오류 발생 시 콘솔에 로깅하고 적절한 기본값을 반환합니다.

코드 (일부 발췌):
// src/utils/supabaseExperiments.ts
import { PitchParameters, SimulationResult } from '@/types'
import { supabase } from '@/lib/supabase'

export interface SupabaseExperiment {
  id: string
  name: string
  params: PitchParameters
  result: SimulationResult
  created_at: string
  updated_at: string
}

export const supabaseExperimentsService = {
  async getAll(limit = 10): Promise<SupabaseExperiment[]> {
    try {
      const { data, error } = await supabase
        .from('experiments')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(limit)

      if (error) throw error

      return (data || []).map(exp => ({
        id: exp.id,
        name: exp.name,
        params: exp.params as PitchParameters,
        result: exp.result as SimulationResult,
        created_at: exp.created_at,
        updated_at: exp.updated_at
      }))
    } catch (error) {
      console.error('Failed to load experiments from Supabase:', error)
      return []
    }
  },

  async save(
    name: string,
    params: PitchParameters,
    result: SimulationResult
  ): Promise<SupabaseExperiment | null> {
    try {
      const { data, error } = await supabase
        .from('experiments')
        .insert({
          name: name || `실험 ${new Date().toLocaleString('ko-KR')}`,
          params: params as unknown,
          result: result as unknown
        })
        .select()
        .single()

      if (error) throw error

      return {
        id: data.id,
        name: data.name,
        params: data.params as PitchParameters,
        result: data.result as SimulationResult,
        created_at: data.created_at,
        updated_at: data.updated_at
      }
    } catch (error) {
      console.error('Failed to save experiment to Supabase:', error)
      return null
    }
  },

  async delete(id: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('experiments')
        .delete()
        .eq('id', id)

      if (error) throw error
      return true
    } catch (error) {
      console.error('Failed to delete experiment from Supabase:', error)
      return false
    }
  }
}


9. 카메라 컨트롤러 컴포넌트 (CameraController.tsx)

기능:
사용자가 선택한 카메라 프리셋에 따라 3D 씬의 카메라 위치와 바라보는 지점을 제어합니다. 포수, 투수, 측면과 같은 고정된 시점과 공을 따라가는 추적 시점, 그리고 사용자가 자유롭게 조작하는 자유 시점 간의 부드러운 전환을 담당합니다.

설명:
- CAMERA_PRESETS: 각 프리셋(catcher, pitcher, side)에 대한 카메라의 위치(position)와 목표 지점(target)을 정의하는 설정 객체입니다.
- useEffect 훅: preset prop이 변경될 때마다 호출됩니다. follow나 free 모드가 아닐 경우, CAMERA_PRESETS에서 해당 프리셋의 설정을 찾아 목표 위치(targetPos)를 업데이트합니다.
- useFrame 훅: @react-three/fiber가 제공하는 이 훅은 매 프레임마다 실행되어 애니메이션을 구현합니다.
- free 모드일 경우, 아무 작업도 하지 않고 OrbitControls에 제어를 맡깁니다.
- follow 모드일 경우, ballPosition prop을 받아와 카메라가 공의 약간 뒤쪽 위에서 공을 부드럽게 따라가도록 위치를 계산하고, lookAt을 사용하여 공을 바라보게 합니다.
- 다른 고정 프리셋의 경우, 현재 카메라 위치에서 목표 위치(targetPos)까지 lerp (선형 보간)를 사용하여 부드럽게 이동시킵니다. 목표 위치에 충분히 가까워지면 이동을 멈춰 불필요한 계산과 떨림을 방지합니다.

코드 (일부 발췌):
// src/core/renderer/CameraController.tsx
import { useThree, useFrame } from '@react-three/fiber'
import { useEffect, useRef } from 'react'
import { Vector3 as ThreeVector3 } from 'three'

export function CameraController({ preset, ballPosition }: CameraControllerProps) {
  const { camera } = useThree()
  const targetPos = useRef(new ThreeVector3())

  useEffect(() => {
    if (preset === 'follow' || preset === 'free') return
    const config = CAMERA_PRESETS[preset]
    if (config) {
      targetPos.current.set(...config.position)
    }
  }, [preset, camera])

  useFrame((_state, delta) => {
    if (preset === 'free') return

    if (preset === 'follow' && ballPosition) {
      const targetLookAt = new ThreeVector3(ballPosition.x, ballPosition.y, ballPosition.z)
      camera.lookAt(currentLookAt)
    }

    const distance = camera.position.distanceTo(targetPos.current)
    if (distance < 0.001) {
      return
    }

    const lerpFactor = Math.min(delta * 2, 1)
    camera.position.lerp(targetPos.current, lerpFactor)

    if (preset !== 'follow') {
      const config = CAMERA_PRESETS[preset]
      if (config) {
        camera.lookAt(...config.target)
      }
    }
  })

  return null
}


10. 야구공 3D 모델 컴포넌트 (Ball3D.tsx)

기능:
시뮬레이션의 주인공인 야구공을 3D 씬에 렌더링합니다. position prop을 받아 해당 위치에 공을 표시하며, 성능 최적화를 위해 React.memo를 사용합니다.

설명:
- React.memo: 이 컴포넌트는 props가 변경되지 않으면 리렌더링되지 않도록 React.memo로 감싸져 있습니다.
- useGraphics 훅: GraphicsContext로부터 그래픽 설정(settings)을 가져옵니다. 이 설정을 통해 sphereSegments 값을 조절하여 공의 폴리곤 수를 동적으로 변경할 수 있습니다.
- mesh: Three.js의 mesh를 사용하여 3D 객체를 생성합니다. position prop으로 받은 좌표를 mesh의 위치로 설정합니다.
- sphereGeometry: 구 형태의 지오메트리를 생성합니다. radius prop으로 공의 크기를, sphereSegments로 구의 정밀도를 설정합니다.
- meshBasicMaterial: 조명의 영향을 받지 않는 단순한 재질을 사용합니다. color prop으로 공의 색상을 지정합니다.

코드:
// src/scenarios/pitch/Ball3D.tsx
import { memo } from 'react'
import { Vector3 } from '@/types'
import { useGraphics } from '@/contexts/GraphicsContext'

interface Ball3DProps {
  position?: Vector3
  radius?: number
  color?: string
}

export const Ball3D = memo(function Ball3D({
  position = { x: 0, y: 0, z: 0 },
  radius = 0.0366,
  color = '#ffffff'
}: Ball3DProps) {
  const { settings } = useGraphics()

  return (
    <mesh position={[position.x, position.y, position.z]}>
      <sphereGeometry args={[radius, settings.sphereSegments, settings.sphereSegments]} />
      <meshBasicMaterial color={color} />
    </mesh>
  )
})


11~17. 나머지 UI 컴포넌트 및 설정 파일

이 외에도 ReplayControls (리플레이 제어), ComparisonPanel (비교 모드 UI), PitchInputPanel (파라미터 입력), LoginPage/SignupPage (인증 페이지), vite.config.ts (빌드 설정), tsconfig.json (TypeScript 설정) 등의 파일이 구현되어 있으며, 각각 앞서 3.4~3.6절에서 설명한 기능들을 코드로 구현하고 있습니다. 모든 컴포넌트는 React 함수형 컴포넌트와 Hooks를 사용하여 작성되었으며, styled-components를 통해 일관된 디자인 시스템을 적용했습니다.




제4장 테스트 및 검증




4.1 단위 테스트

4.1.1 테스트 환경

프로젝트의 물리 계산 로직과 유틸리티 함수들의 정확성을 검증하기 위해 Jest 테스트 프레임워크를 사용하여 단위 테스트를 수행했습니다.

테스트 도구:
- 테스트 프레임워크: Jest 30.2.0
- TypeScript 지원: ts-jest
- 테스트 대상: 물리 계산 함수, 벡터 연산 함수

테스트 환경 설정:
- 테스트 파일 위치: src/core/physics/
- 테스트 파일 명명 규칙: *.test.ts
- 실행 명령: npm test

테스트 요약:
- 총 테스트 수: 31개
- 통과: 31개 (100%)
- 실패: 0개
- 실행 시간: 2.407초


4.1.2 공기 밀도 계산 테스트 (calculateAirDensity)

공기 밀도 계산 함수는 이상 기체 법칙을 기반으로 온도, 기압, 습도에 따른 공기 밀도를 계산합니다.

테스트 케이스 및 결과:

1. 표준 조건 테스트:
입력: 온도 20°C, 기압 1013.25 hPa, 습도 50%
실제 출력: 1.199 kg/m³
예상 범위: 1.199 kg/m³ (±0.005)
상태: PASS

2. 고온 vs 저온 비교:
입력: 고온 40°C, 저온 0°C (기압 1013.25 hPa, 습도 50%)
결과: 고온 밀도 < 저온 밀도
차이: -0.179 kg/m³ (-13.9%)
해석: 온도 40°C 상승 시 밀도 13.9% 감소 (물리적으로 타당)
상태: PASS

3. 고압 vs 저압 비교:
입력: 고압 1100 hPa, 저압 900 hPa (온도 20°C, 습도 50%)
결과: 고압 밀도 > 저압 밀도
차이: +0.238 kg/m³ (+22.3%)
해석: 기압 200 hPa 상승 시 밀도 22.3% 증가 (물리적으로 타당)
상태: PASS

4. 고습 vs 저습 비교:
입력: 고습 90%, 저습 10% (온도 20°C, 기압 1013.25 hPa)
결과: 고습 밀도 < 저습 밀도
차이: -0.008 kg/m³ (-0.7%)
해석: 습도 80% 상승 시 밀도 0.7% 감소 (영향 미미하지만 물리적으로 정확)
상태: PASS

검증 공식: ρ = (p / (R × T)) × (1 - 0.378 × e / p)


4.1.3 중력 계산 테스트 (calculateGravity)

중력 계산 함수는 F = m × g 공식을 사용하여 공에 작용하는 중력을 계산합니다.

테스트 케이스 및 결과:

1. 표준 중력 테스트:
입력: 질량 0.145 kg, 중력 가속도 9.81 m/s²
실제 출력: F_y = -1.422 N
예상 출력: -1.422 N (±0.001)
상태: PASS

2. 질량 비례 테스트:
입력: m₁=0.1kg, m₂=0.2kg (중력 9.81 m/s²)
결과: |F₂| > |F₁|
해석: 질량 2배 → 힘 2배 (선형 비례)
상태: PASS

3. 중력 가속도 비례 테스트:
입력: g₁=9.78 m/s², g₂=9.83 m/s² (질량 0.145 kg)
결과: |F₂| > |F₁|
해석: 중력 가속도 증가 → 힘 증가 (선형 비례)
상태: PASS

검증 공식: F = m × g × [0, -1, 0]


4.1.4 항력 계산 테스트 (calculateDrag)

항력 계산 함수는 속도의 제곱에 비례하는 항력을 계산합니다.

테스트 케이스 및 결과:

1. 정지 상태 테스트:
입력: 속도 0 m/s
실제 출력: F = (0, 0, 0)
예상 출력: 0 N (경계 조건)
상태: PASS

2. 방향 검증 테스트:
입력: 속도 (0, 0, -40) m/s (Z축 음의 방향)
결과: F_z > 0 (양의 방향)
해석: 속도 반대 방향으로 작용 (물리적으로 정확)
상태: PASS

3. 속도 제곱 비례 테스트:
입력: v₁=20 m/s, v₂=40 m/s
결과: |F₂| ≈ 4×|F₁|
해석: 속도 2배 → 항력 4배 (v² 비례)
상태: PASS

4. 공기 밀도 비례 테스트:
입력: ρ₁=1.0 kg/m³, ρ₂=1.5 kg/m³
결과: |F₂| > |F₁|
해석: 공기 밀도 증가 → 항력 증가 (ρ 비례)
상태: PASS

검증 공식: F = -0.5 × ρ × C_d × A × v² × v̂

실제 계산 예시 (v=40 m/s, ρ=1.225 kg/m³):
A = π × (0.0366)² = 0.00421 m²
F = 0.5 × 1.225 × 0.4 × 0.00421 × 40² = 0.823 N


4.1.5 마그누스 효과 테스트 (calculateMagnus)

마그누스 효과 계산 함수는 회전하는 공에 작용하는 양력을 계산합니다.

테스트 케이스 및 결과:

1. 무회전 테스트:
입력: 회전 0 rpm
실제 출력: F = (0, 0, 0)
예상 출력: 0 N (경계 조건)
상태: PASS

2. 백스핀 테스트:
입력: 속도 (0, 0, -40) m/s, 회전 (2400, 0, 0) rpm
결과: F_y > 0 (위쪽 방향)
해석: 백스핀 → 위쪽 양력 발생 (물리적으로 정확)
상태: PASS

3. 회전수 비례 테스트:
입력: ω₁=1200 rpm, ω₂=2400 rpm
결과: |F₂| > |F₁|
해석: 회전수 증가 → 힘 증가 (ω 비례)
상태: PASS

4. 속도 비례 테스트:
입력: v₁=30 m/s, v₂=45 m/s
결과: |F₂| > |F₁|
해석: 속도 증가 → 힘 증가 (v 비례)
상태: PASS

검증 공식: F = C_L × ρ × π × r³ × |v| × (ω × v̂)

실제 계산 예시 (v=40 m/s, ω=2400 rpm):
ω = 2400 × (2π/60) = 251.3 rad/s
F_magnus ≈ 0.156 N (위쪽)


4.1.6 벡터 연산 함수 테스트

기본 벡터 연산 함수들의 정확성을 검증했습니다.

1. 기본 벡터 연산:
- vec3.create(1, 2, 3) → {x:1, y:2, z:3} (PASS)
- vec3.add((1,2,3), (4,5,6)) → (5,7,9) (PASS)
- vec3.subtract((5,7,9), (1,2,3)) → (4,5,6) (PASS)
- vec3.multiply((1,2,3), 3) → (3,6,9) (PASS)
- vec3.multiply((5,10,15), 0) → (0,0,0) (PASS)

2. 벡터 크기 및 정규화:
- vec3.length((3,4,0)) → 5.0 (3-4-5 삼각형, PASS)
- vec3.length((0,0,0)) → 0.0 (영벡터, PASS)
- vec3.length((1,2,2)) → 3.0 (√9, PASS)
- vec3.normalize((3,4,0)) → (0.6, 0.8, 0) (크기 1.0, PASS)
- vec3.normalize((1,0,0)) → (1,0,0) (이미 정규화됨, PASS)
- vec3.normalize((0,0,0)) → (0,0,0) (영벡터 유지, PASS)

3. 내적 및 외적:
- vec3.dot((1,2,3), (4,5,6)) → 32 (1×4 + 2×5 + 3×6, PASS)
- vec3.dot((1,0,0), (0,1,0)) → 0 (수직, PASS)
- vec3.cross((1,0,0), (0,1,0)) → (0,0,1) (오른손 법칙, PASS)
- vec3.cross((2,4,6), (1,2,3)) → (0,0,0) (평행 벡터, PASS)
- 외적 결과의 수직성 검증: cross · v₁ = 0, cross · v₂ = 0 (PASS)


4.1.7 테스트 커버리지

테스트 커버리지 요약:
- Test Suites: 2 passed, 2 total
- Tests: 31 passed, 31 total
- Time: 2.407 s

테스트 파일 구성:
- src/core/physics/forces.test.ts: 물리 계산 함수 (15개 테스트)
- src/core/physics/integrator.test.ts: 벡터 연산 함수 (16개 테스트)

결론:
모든 물리 계산 함수가 수학적 공식과 일치하는 결과를 출력함을 검증했습니다. 공기 밀도는 이상 기체 법칙 기반 계산 정확도 ±0.5%, 중력/항력/마그누스는 뉴턴 역학 법칙 완벽 준수, 벡터 연산은 선형대수 기본 법칙 100% 정확함을 확인했습니다. 또한 경계 조건 처리(속도 0일 때 항력/마그누스 힘 = 0, 회전 0일 때 마그누스 힘 = 0, 영벡터 정규화 안전 처리)가 올바르게 구현되었으며, 물리적 타당성(항력은 속도의 제곱에 비례, 마그누스 효과는 속도 × 회전수에 비례, 백스핀 시 양력 발생)이 검증되었습니다.


4.2 통합 테스트

4.2.1 3D 렌더링 테스트

테스트 항목:
힘 벡터(중력, 항력, 마그누스) 시각화 정확성 검증

테스트 방법:
Storybook을 사용하여 각 벡터 컴포넌트를 독립적으로 렌더링하고, 시각적으로 방향과 색상이 올바른지 확인했습니다.

결과:
중력(파란색, 아래), 항력(빨간색, 속도 반대), 마그누스(녹색, ω × v) 규칙에 맞게 정상 출력되었습니다.

4.2.2 데이터베이스 연동 테스트

테스트 항목:
Supabase API를 통한 실험 데이터 CRUD(Create, Read, Update, Delete) 기능

테스트 방법:
테스트용 Supabase 프로젝트에서 supabaseExperiments.ts 유틸리티 함수를 직접 실행하며 RLS 정책이 올바르게 적용되는지 확인했습니다.

결과:
자신의 데이터만 접근 가능함을 확인했습니다. 타 사용자 데이터 접근 시 차단되었습니다.

4.2.3 UI 인터랙션 테스트

테스트 항목:
파라미터 변경 시 시뮬레이션 상태가 올바르게 업데이트되는지 검증

테스트 방법:
React Testing Library를 사용하여 PitchInputPanel 컴포넌트의 입력 필드를 변경하고, SimulationContext의 상태 값이 변경되는지 확인했습니다.

결과:
모든 입력 필드가 정상적으로 상태와 연동됨을 확인했습니다.


4.3 성능 테스트

4.3.1 성능 모니터링

측정 지표:
- FPS (Frames Per Second)
- 초기 로딩 시간
- 시뮬레이션 계산 시간

측정 도구:
- stats.js
- Chrome DevTools (Lighthouse, Performance)
- performance.now()

목표 성능:
- FPS: 30fps 이상 (저사양 PC 기준)
- 초기 로딩 시간: 3초 미만
- 시뮬레이션 계산 시간: 100ms 미만

실측 결과 (RTX 2050+ 환경):
- 물리 계산: 1.6~4.7 ms (매우 빠름, 목표 달성)
- 애니메이션 중 렌더링: 30~45 FPS (목표 달성)
- 애니메이션 완료 후: 55~60 FPS (목표 초과 달성)
- 초기 로딩 시간: 약 2.1초 (목표 달성)

결론:
목표 성능(30fps, 로딩 3초, 계산 100ms)을 모두 달성했습니다.

4.3.2 메모리 최적화

문제점:
시뮬레이션을 반복 실행할 경우, 이전 궤적 데이터가 메모리에 남아 누수가 발생하는 문제가 있었습니다.

개선 방법:
useEffect의 cleanup 함수를 사용하여 컴포넌트 언마운트 시 Three.js 객체(geometry, material, texture)를 명시적으로 dispose()하여 메모리를 해제했습니다.

결과:
메모리 누수가 해결되었으며, 장시간 사용 시에도 안정성을 확보했습니다.

4.3.3 렌더링 최적화

문제점:
궤적 라인이 수백개의 포인트로 구성되어 렌더링 부하가 높았습니다.

개선 방법:
- TubeGeometry 대신 Line을 사용
- 궤적 포인트 수를 그래픽 설정에서 조절 가능하도록 변경
- React.memo 적용

결과:
궤적 렌더링 성능이 50% 이상 향상되었습니다.

4.3.4 코드 최적화

적용된 최적화 기법:
- React.memo 적용: Ball3D, TrajectoryLine 등 순수 컴포넌트에 적용하여 불필요한 리렌더링 방지
- 불필요한 리렌더링 제거: useCallback을 사용하여 이벤트 핸들러 함수를 메모이제이션
- 기타 최적화: Code Splitting (React.lazy)을 일부 무거운 컴포넌트에 적용하여 초기 로딩 속도 개선


4.4 사용자 테스트

4.4.1 테스트 대상 및 방법

테스트 대상:
- 고등학생 5명 (물리 과목 수강 중)
- 물리 교사 2명

테스트 방법:
1. 간단한 사용법 안내 (5분)
2. 자유롭게 시뮬레이터 사용 (15분)
3. 설문 조사 및 인터뷰 (10분)

4.4.2 피드백 요약

긍정적 피드백:
- 3D 시각화가 직관적이고 이해하기 쉬움
- 리플레이 기능이 유용함
- 파라미터 변경 시 실시간 반응이 재미있음
- 비교 모드로 실험 결과를 쉽게 비교할 수 있음

개선 제안:
- 모바일 지원 필요 (반응형 UI)
- 도움말 내용이 더 자세했으면 좋겠음
- 저장된 실험을 친구와 공유하고 싶음 (URL 공유 기능)

4.4.3 개선 사항 반영

반영된 개선 사항:
- 도움말 모달 내용 확장 (FAQ 추가, 키보드 단축키 설명)
- 그래픽 설정 패널 추가 (저사양 기기 지원)

보류된 개선 사항:
- 모바일 반응형 UI (Phase 3로 연기)
- URL 공유 기능 (보안 이슈로 보류)




제5장 실행 화면




5.1 로그인 및 회원가입 화면

5.1.1 회원가입 화면

회원가입 페이지는 이메일, 비밀번호, 사용자 이름, 역할을 입력받아 Supabase Auth를 통해 계정을 생성합니다.

주요 구성 요소:
- 애니메이션 배경: 떠다니는 그라디언트 Orb 3개 (20초 순환)
- 그라디언트 타이틀: Primary 색상 그라디언트 적용
- 입력 필드: 이메일, 비밀번호, 사용자 이름
- 역할 선택: 학생 / 교사 (대형 아이콘 버튼)
- 기능 소개: 하단 3개 아이콘 리스트 (실시간 계산, 3D 시각화, 데이터 분석)

화면 설명 (이미지 위치 표시):
[이미지 위치: 회원가입 화면 스크린샷]
- 역할 선택 UI가 돋보이는 디자인
- 글래스모피즘 효과 적용

5.1.2 로그인 화면

로그인 페이지는 이메일과 비밀번호를 입력받아 Supabase Auth로 인증합니다.

주요 구성 요소:
- 동일한 애니메이션 배경
- 이메일 / 비밀번호 입력 필드
- 로그인 버튼 (로딩 상태 표시)
- 회원가입 링크

화면 설명 (이미지 위치 표시):
[이미지 위치: 로그인 화면 스크린샷]
- 간결한 UI
- 오류 메시지 표시 영역


5.2 메인 시뮬레이터 화면

5.2.1 전체 레이아웃

시뮬레이터 메인 화면은 좌우 분할 레이아웃으로 구성됩니다.

화면 구성:
- 상단 네비게이션 바 (48px)
- 좌측 3D 뷰어 영역 (flex: 1)
- 우측 컨트롤 패널 (420px)

화면 설명 (이미지 위치 표시):
[이미지 위치: 메인 시뮬레이터 화면 전체 스크린샷]
- 3D 뷰어 테두리 글로우 효과 확인
- 4개 탭 구조 확인

5.2.2 3D 뷰어 영역

3D 뷰어는 Three.js를 사용하여 실시간 3D 시뮬레이션을 표시합니다.

주요 요소:
- 투수 3D 모델 (블렌더 제작, 846KB, 280 폴리곤)
- 야구공 궤적 (라인 렌더링)
- 스트라이크 존 (반투명 평면)
- 카메라 프리셋 버튼 (우측 상단)
- 리플레이 컨트롤 (하단)

화면 설명 (이미지 위치 표시):
[이미지 위치: 3D 뷰어 화면 스크린샷]
- 투수 모델 애니메이션 확인
- 궤적 라인 시각화 확인


5.3 투수 3D 모델 및 애니메이션

5.3.1 우완/좌완 자동 판정

릴리스 포인트 X 좌표에 따라 우완/좌완을 자동 판정하여 모델을 미러링합니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 우완 투수 모델 스크린샷]
- X > 0: 우완 투수

[이미지 위치: 좌완 투수 모델 스크린샷]
- X < 0: 좌완 투수 (Y축 미러링)

5.3.2 투구 폼별 자세

릴리스 포인트 Y 좌표에 따라 투구 폼이 자동 분류됩니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 오버핸드 폼 스크린샷]
- Y ≥ 2.3: 오버핸드

[이미지 위치: 사이드암 폼 스크린샷]
- 1.3 ≤ Y < 1.8: 사이드암


5.4 파라미터 입력 및 결과 표시

5.4.1 파라미터 입력 패널

15개의 물리 파라미터를 3단 구조로 입력받습니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 파라미터 입력 패널 스크린샷]
- 투구 조건, 공 물성, 환경 변수 구분
- 툴팁 표시 확인

5.4.2 결과 패널

시뮬레이션 완료 후 주요 결과를 카드 형태로 표시합니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 결과 패널 스크린샷]
- 스트라이크/볼 판정 (그라디언트 배경)
- 7개 결과 항목 (비행 시간, 최고 높이, 수평 변화 등)


5.5 리플레이 및 카메라 제어

5.5.1 리플레이 컨트롤

리플레이 컨트롤은 하단에 배치되어 시뮬레이션 결과를 다시 볼 수 있습니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 리플레이 컨트롤 스크린샷]
- 타임라인 슬라이더 (그라디언트 진행 바)
- 재생/일시정지 버튼 (원형, 글로우 효과)
- 속도 조절 버튼 (0.25x, 0.5x, 1x, 2x)

5.5.2 카메라 프리셋 버튼

6개의 카메라 프리셋을 제공합니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 카메라 프리셋 버튼 스크린샷]
- 3x2 그리드 레이아웃
- 활성 상태 글로우 효과
- 야구 테마 아이콘


5.6 비교 모드

5.6.1 비교 모드 UI

두 개의 실험을 선택하여 비교합니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 비교 모드 UI 스크린샷]
- 드롭다운 선택 (실험 A, 실험 B)
- 실험 정보 미리보기

5.6.2 비교 결과 화면

3D 뷰어에 2개 궤적을 동시 표시하고, 결과를 표로 비교합니다.

화면 설명 (이미지 위치 표시):
[이미지 위치: 비교 결과 화면 스크린샷]
- 파란색 궤적 (실험 A)
- 빨간색 궤적 (실험 B)
- 차이값 표시 (A-B)




제6장 설치 및 실행 방법




6.1 시스템 요구사항

6.1.1 하드웨어 요구사항

최소 사양:
- CPU: Intel Core i5 9세대 이상 또는 동급
- RAM: 4GB 이상
- GPU: 내장 그래픽 (WebGL 1.0 지원)
- 저장 공간: 500MB 이상

권장 사양:
- CPU: Intel Core i7 9세대 이상 또는 동급
- RAM: 8GB 이상
- GPU: NVIDIA GTX 1650 이상 또는 동급 (WebGL 2.0 지원)
- 저장 공간: 1GB 이상

6.1.2 소프트웨어 요구사항

필수 소프트웨어:
- Node.js: v20.x 이상
- npm: v10.x 이상

지원 브라우저:
- Google Chrome: v90 이상 (권장)
- Mozilla Firefox: v88 이상
- Microsoft Edge: v90 이상
- Safari: v14 이상 (macOS)


6.2 설치 방법

6.2.1 저장소 복제

GitHub 저장소에서 프로젝트를 복제합니다.

명령어:
git clone https://github.com/yh20studio/physics-simulator.git
cd physics-simulator

6.2.2 의존성 설치

프로젝트의 모든 의존성 패키지를 설치합니다.

명령어:
npm install

설치되는 주요 패키지:
- react (v18.2.0)
- three (v0.158.0)
- @supabase/supabase-js (v2.x)
- styled-components (v6.1.1)
- typescript (v5.2.2)

예상 소요 시간: 약 2~3분

6.2.3 환경 변수 설정

Supabase 연동을 위한 환경 변수를 설정합니다.

파일 생성:
프로젝트 루트 디렉토리에 .env 파일을 생성합니다.

내용:
VITE_SUPABASE_URL=your_supabase_url
VITE_SUPABASE_ANON_KEY=your_supabase_anon_key

주의사항:
- Supabase 프로젝트가 없는 경우, https://supabase.com 에서 무료 계정을 생성해야 합니다.
- .env 파일은 절대로 Git에 커밋하지 않습니다 (.gitignore에 포함됨).


6.3 실행 방법

6.3.1 개발 모드 실행

개발 모드에서 애플리케이션을 실행합니다.

명령어:
npm run dev

실행 결과:
VITE v5.x.x ready in xxx ms
➜ Local:   http://localhost:3000/
➜ Network: http://192.168.x.x:3000/

접속 방법:
웹 브라우저에서 http://localhost:3000 으로 접속합니다.

개발 모드 특징:
- Hot Module Replacement (HMR) 지원
- 소스 맵 활성화 (디버깅 용이)
- 빠른 빌드 시간 (Vite 사용)

6.3.2 프로덕션 빌드

프로덕션 배포를 위한 빌드를 수행합니다.

명령어:
npm run build

빌드 과정:
1. TypeScript 타입 체크
2. Vite 빌드 (최적화 및 번들링)
3. dist 디렉토리에 정적 파일 생성

예상 소요 시간: 약 30~60초

빌드 결과:
dist/
├── index.html
├── assets/
│   ├── index-[hash].js
│   ├── index-[hash].css
│   └── models/
│       └── pitcher.fbx
└── ...

6.3.3 프로덕션 미리보기

빌드된 프로덕션 버전을 로컬에서 미리 확인합니다.

명령어:
npm run preview

접속 방법:
웹 브라우저에서 http://localhost:4173 으로 접속합니다.


6.4 사용 방법

6.4.1 초기 설정

1. 회원가입:
   - /signup 페이지에서 새 계정 생성
   - 이메일, 비밀번호, 사용자 이름, 역할 입력

2. 로그인:
   - /login 페이지에서 로그인
   - 이메일 인증 완료 후 접속 가능

6.4.2 시뮬레이션 실행

1. 파라미터 입력:
   - 우측 패널의 "파라미터" 탭에서 15개 파라미터 입력
   - 입력 예시 버튼을 활용하여 빠른 설정 가능

2. 시뮬레이션 시작:
   - "시뮬레이션 시작" 버튼 클릭
   - 투수 모델이 투구 애니메이션 시작
   - 48프레임에서 공이 생성되어 비행

3. 결과 확인:
   - "결과" 탭에서 스트라이크/볼 판정 확인
   - 7개 결과 항목 확인 (비행 시간, 최고 높이 등)

4. 리플레이:
   - 하단 리플레이 컨트롤로 재생/일시정지
   - 타임라인 슬라이더로 원하는 시점 이동
   - 속도 조절 버튼으로 재생 속도 변경

6.4.3 실험 저장 및 비교

1. 실험 저장:
   - "결과" 탭에서 "저장" 버튼 클릭
   - 실험 이름 입력 후 저장

2. 최근 실험 확인:
   - "최근 실험" 탭에서 저장된 실험 목록 확인
   - 불러오기, 상세보기, 삭제 가능

3. 비교 모드:
   - "비교" 탭에서 2개 실험 선택
   - "비교 시작" 버튼 클릭
   - 3D 뷰어에 2개 궤적 동시 표시
   - 결과 표로 차이값 확인




제7장 결론




7.1 프로젝트 요약

본 프로젝트는 물리 법칙을 3D 시각화로 학습할 수 있는 교육용 웹 애플리케이션을 개발하는 것을 목표로 하였습니다. 1차 모듈로 야구 투구 시뮬레이터를 구현하였으며, 중력, 항력, 마그누스 효과를 포함한 정확한 물리 계산과 실시간 3D 렌더링을 통해 사용자가 물리 법칙을 직관적으로 이해할 수 있도록 하였습니다.

주요 구현 내용:
- 4차 Runge-Kutta 수치 적분을 사용한 정밀한 물리 시뮬레이션
- Three.js 기반 실시간 3D 렌더링 (블렌더 투수 모델, 궤적 시각화)
- 15개 파라미터 직접 입력 UI (3단 구조: 공 물성, 투구 조건, 환경 변수)
- 리플레이 시스템 (재생/일시정지, 속도 조절, 타임라인 스크러빙)
- 다중 카메라 시점 (포수, 투수, 측면, 공 추적, 자유)
- 실험 저장 및 비교 기능 (Supabase 연동, 2개 궤적 동시 표시)
- 그래픽 설정 패널 (성능 최적화, 저사양 지원)
- 사용자 인증 시스템 (Supabase Auth, RLS 정책)


7.2 기술적 성과

7.2.1 물리 엔진 정확도

Jest를 사용한 단위 테스트 결과, 모든 물리 계산 함수가 수학적 공식과 일치하는 결과를 출력함을 검증하였습니다 (31개 테스트, 100% 통과). 공기 밀도는 이상 기체 법칙 기반 계산 정확도 ±0.5%, 중력/항력/마그누스는 뉴턴 역학 법칙을 완벽히 준수하며, 벡터 연산은 선형대수 기본 법칙을 100% 정확하게 구현하였습니다.

7.2.2 성능 최적화

목표 성능 (30fps, 로딩 3초, 계산 100ms)을 모두 달성하였습니다. 실측 결과 (RTX 2050+ 환경), 물리 계산은 1.6~4.7ms로 매우 빠르며, 애니메이션 중 렌더링은 30~45 FPS, 애니메이션 완료 후 55~60 FPS를 기록하였습니다. 초기 로딩 시간은 약 2.1초로 목표를 달성하였습니다.

7.2.3 확장 가능한 아키텍처

모듈식 설계 (core, scenarios, components)를 통해 새로운 시나리오 추가 시간을 약 30분으로 단축하였습니다. 공통 코어 (physics, renderer, ui)를 재사용하여 개발 효율성을 극대화하였으며, TypeScript를 사용한 강타입 시스템으로 유지보수성을 향상시켰습니다.


7.3 교육적 효과

7.3.1 직관적 학습 경험

3D 시각화를 통해 추상적인 물리 법칙(마그누스 효과, 항력 등)을 눈으로 확인할 수 있어 학습 효과가 크게 향상되었습니다. 사용자 테스트 결과, 고등학생 5명과 물리 교사 2명 모두 "직관적이고 이해하기 쉽다"는 긍정적인 피드백을 제공하였습니다.

7.3.2 실험 중심 학습

파라미터를 직접 변경하며 결과를 실시간으로 확인할 수 있어 능동적인 학습이 가능합니다. 비교 모드를 통해 실험 결과를 쉽게 비교하고 분석할 수 있으며, 저장 기능으로 학습 진행 상황을 기록할 수 있습니다.

7.3.3 교사 활용 가능성

물리 교사는 수업 자료로 활용하여 학생들의 흥미를 유발하고, 개념 설명을 보조할 수 있습니다. 도움말 모달에는 FAQ와 키보드 단축키 설명이 포함되어 있어 교육 현장에서 바로 활용 가능합니다.


7.4 한계점 및 개선 방향

7.4.1 현재 한계점

1. 모바일 지원 부족:
   - 반응형 UI가 부분적으로만 구현됨 (768px 미만 지원 미흡)
   - 터치 제스처 미지원

2. 단일 시나리오:
   - 현재 야구 투구 시뮬레이터만 구현됨
   - 다른 물리 법칙 (충돌, 진자 운동 등) 미구현

3. 협업 기능 부족:
   - 실험 공유 기능 (URL) 미구현
   - 교사-학생 과제 기능 미구현

4. 렌더링 최적화 여지:
   - LOD (Level of Detail) 미적용
   - 궤적 라인 단순화 필요 (매우 긴 궤적의 경우)

7.4.2 향후 개선 방향

1. 모바일 최적화 (Phase 3):
   - 하단 시트 UI 구현 (모바일)
   - 터치 제스처 지원 (핀치 줌, 스와이프 회전)
   - QR 코드 기능 (모바일 접속 편의성)

2. 추가 시나리오 개발:
   - 포물선 운동 (일반화)
   - 진자 운동 (단진자, 복진자)
   - 충돌 실험 (탄성/비탄성)
   - 중력 도움 퍼즐 게임 (협업 기반, 휴대폰 활용)

3. 협업 기능 추가:
   - 실험 URL 공유 (보안 강화)
   - 교사-학생 과제 시스템
   - 리더보드 및 랭킹 (미니게임)

4. 성능 추가 최적화:
   - LOD 시스템 구현
   - 궤적 라인 적응형 샘플링
   - Web Workers 활용 (물리 계산 병렬화)


7.5 최종 결론

본 프로젝트를 통해 물리 법칙을 실시간 3D 시각화로 학습할 수 있는 교육용 웹 애플리케이션을 성공적으로 개발하였습니다. 정밀한 물리 계산, 직관적인 3D 시각화, 그리고 사용자 친화적인 UI를 통해 학습자가 능동적으로 물리 법칙을 탐구할 수 있는 환경을 제공하였습니다.

단위 테스트를 통해 물리 계산의 정확성을 검증하였으며, 성능 테스트를 통해 목표 성능을 모두 달성하였습니다. 사용자 테스트 결과, 직관적이고 이해하기 쉬운 학습 경험을 제공함을 확인하였습니다.

향후 모바일 최적화, 추가 시나리오 개발, 협업 기능 추가 등을 통해 더욱 완성도 높은 교육 도구로 발전시킬 계획입니다. 본 프로젝트가 물리 교육의 새로운 가능성을 제시하고, 학습자의 흥미와 이해도를 높이는 데 기여할 수 있기를 기대합니다.




부록 I. 작품 사진

[이미지 위치: 회원가입 화면 스크린샷]
그림 1. 회원가입 화면 - 역할 선택 UI 및 글래스모피즘 효과

[이미지 위치: 로그인 화면 스크린샷]
그림 2. 로그인 화면 - 간결한 인증 UI

[이미지 위치: 메인 시뮬레이터 화면 전체 스크린샷]
그림 3. 메인 시뮬레이터 화면 - 좌우 분할 레이아웃

[이미지 위치: 3D 뷰어 화면 스크린샷]
그림 4. 3D 뷰어 영역 - 투수 모델 및 궤적 시각화

[이미지 위치: 우완 투수 모델 스크린샷]
그림 5. 우완 투수 모델 (X > 0)

[이미지 위치: 좌완 투수 모델 스크린샷]
그림 6. 좌완 투수 모델 (X < 0, Y축 미러링)

[이미지 위치: 오버핸드 폼 스크린샷]
그림 7. 오버핸드 투구 폼 (Y ≥ 2.3)

[이미지 위치: 사이드암 폼 스크린샷]
그림 8. 사이드암 투구 폼 (1.3 ≤ Y < 1.8)

[이미지 위치: 파라미터 입력 패널 스크린샷]
그림 9. 파라미터 입력 패널 - 3단 구조 (15개 파라미터)

[이미지 위치: 결과 패널 스크린샷]
그림 10. 결과 패널 - 스트라이크/볼 판정 및 7개 결과 항목

[이미지 위치: 리플레이 컨트롤 스크린샷]
그림 11. 리플레이 컨트롤 - 타임라인 슬라이더 및 속도 조절

[이미지 위치: 카메라 프리셋 버튼 스크린샷]
그림 12. 카메라 프리셋 버튼 - 6개 시점 전환

[이미지 위치: 비교 모드 UI 스크린샷]
그림 13. 비교 모드 UI - 2개 실험 선택

[이미지 위치: 비교 결과 화면 스크린샷]
그림 14. 비교 결과 화면 - 2개 궤적 동시 표시 및 차이값 표



부록 II. 포스터

[이미지 위치: 졸업작품 포스터 이미지]
- 프로젝트 제목: 교육용 3D 물리 시뮬레이터
- 주요 기능: 실시간 3D 시각화, 정밀한 물리 계산, 비교 분석
- 기술 스택: React, TypeScript, Three.js, Supabase
- 작성자: 이영호, 구태훈



부록 III. 주요 소스 코드

부록 III에는 프로젝트의 핵심 로직을 담은 주요 소스 코드를 수록합니다. 본문 3.7절에서 설명한 17개 파일 외에, 다음과 같은 추가 파일들의 전체 소스 코드가 포함됩니다:

- Pitcher3D.tsx: 블렌더 투수 3D 모델 로더 및 애니메이션 제어
- TrajectoryLine.tsx: 궤적 라인 렌더링 컴포넌트
- StrikeZone3D.tsx: 스트라이크 존 3D 표시
- RecentExperimentsPanel.tsx: 최근 실험 목록 UI
- ExperimentDetailModal.tsx: 실험 상세보기 모달
- ComparisonResultTable.tsx: 비교 결과 표
- GraphicsSettingsPanel.tsx: 그래픽 설정 UI
- DebugPanel.tsx: 디버그 및 성능 모니터링 UI
- HelpModal.tsx: 도움말 모달 (FAQ, 키보드 단축키)
- TopNavigationBar.tsx: 상단 네비게이션 바
- ProtectedRoute.tsx: 로그인 가드 컴포넌트
- theme.ts: 디자인 시스템 (색상, 타이포그래피, 간격 등)
- GlobalStyles.tsx: 전역 스타일 설정

(주: 실제 졸업 작품 보고서 제출 시 위 파일들의 전체 소스 코드를 부록에 추가로 첨부합니다.)



--- 본문 끝 ---
