프로젝트 설계 명세서

교육용 3D 물리 시뮬레이터 - 야구 투구 모듈

작성자: ㅇㅇㅎ, ㄱㅌㅎ

문서 버전: v4 (2025-10-30)

주요 변경사항 (v4):
- Supabase Auth 및 데이터베이스 연동 (로그인 필수 정책)
- 비교 모드 구현 완료
- 데이터베이스 스키마 추가 (profiles, experiments, minigame_scores)


목차

1. 개요
   1.1 프로젝트 목표
   1.2 하드웨어, 소프트웨어 개발 환경
   1.3 소프트웨어(서비스) 주요 기능
   1.4 설계상 제약사항
   1.5 참조된 개발문서

2. 프로젝트 구조
   2.1 프로젝트 시스템 구조 개요
   2.2 프로젝트 구조도
   2.3 자료 사전

3. 모듈 설계
   3.1 물리 엔진 모듈
   3.2 3D 렌더링 모듈
   3.3 상태 관리 모듈
   3.4 UI 모듈
   3.5 사용자 인증 모듈
   3.6 데이터 저장 모듈
   3.7 리플레이 모듈
   3.8 카메라 제어 모듈
   3.9 미니게임 모듈
   3.10 비교 모드 모듈
   3.11 공유 기능 모듈
   3.12 성능 최적화 모듈
   3.13 에러 처리 모듈

4. 파일 구조 및 데이터베이스(DB) 설계
   4.1 외부 파일(데이터베이스)의 논리적 구조
   4.2 공유 자료
   4.3 파일 접근 방법(데이터베이스 관리체계; DBMS)

5. 요구 분석 참조표

6. 제약사항

7. 참고 사항


1. 개요

1.1 프로젝트 목표

본 프로젝트는 고등학교 및 대학교 물리 교육을 위한 확장 가능한 웹 기반 3D 물리 시뮬레이터 플랫폼을 개발하는 것을 목표로 합니다.

1차 모듈로 야구 투구 시뮬레이터를 구현하며, 향후 포물선 운동, 진자 운동 등 다양한 물리 시나리오로 쉽게 확장 가능한 설계를 적용합니다.

주요 목표:
1. 확장 가능한 아키텍처: 새 시나리오 추가 시 코드 중복 최소화 (재사용률 80% 이상)
2. 물리 법칙의 직관적 시각화 (힘 벡터 표시, 슬로우 모션)
3. 저사양 PC(Intel 9세대 CPU)에서도 원활한 실행 (30fps 이상)
4. 사용자 계정 및 소셜 기능을 통한 참여 유도
5. 교육기관 대상 B2B 판매를 고려한 모듈화 설계

1.2 하드웨어, 소프트웨어 개발 환경

1.2.1 하드웨어 개발 환경

| 항목 | 사양 |
|---|---|
| 개발 PC | Intel Core i5 이상, 8GB RAM, SSD |
| 테스트 환경 (저사양) | Intel Core i3-9100 (9세대), 4GB RAM, HDD |
| 테스트 환경 (권장) | Intel Core i5-12400, 16GB RAM, SSD |

1.2.2 소프트웨어 개발 환경

프론트엔드:
- 언어: TypeScript 5.x (strict mode)
- 프레임워크: React 18.3.x
- 3D 엔진: Three.js r170 (via @react-three/fiber 8.x)
- 상태 관리: React Context API (제네릭 패턴 적용)
- 스타일링: Styled-components 6.x
- 빌드 도구: Vite 5.x
- 타입 체크: TypeScript + ESLint

백엔드:
- BaaS: Supabase (PostgreSQL + Auth + Storage)
- 인증: Supabase Auth (JWT 기반)
- 클라이언트: @supabase/supabase-js 2.x
- 유효성 검증: TypeScript 타입 체크

데이터베이스:
- DBMS: Supabase PostgreSQL
- Row Level Security (RLS) 활성화

개발 도구:
- 에디터: Visual Studio Code
- 버전 관리: Git + GitHub
- API 테스트: Postman / Thunder Client
- DB 관리: pgAdmin 4, DBeaver
- 다이어그램: Mermaid Live Editor

1.3 소프트웨어(서비스) 주요 기능

1.3.1 핵심 기능 목록

1. 확장 가능한 물리 시뮬레이션 플랫폼
   - 제네릭 BaseSimulator 추상 클래스
   - 시나리오별 Simulator 구현 (PitchSimulator, ProjectileSimulator 등)
   - 중력, 항력, 마그누스 효과 등 재사용 가능한 힘 계산 함수

2. 3D 시각화
   - Three.js 기반 실시간 렌더링
   - 물리력 벡터 시각화 (중력: 파란색, 항력: 빨간색, 마그누스: 녹색)
   - 회전 방향 표시 (회전 화살표)
   - 클로즈업 모드 (공을 따라가는 카메라)

3. 리플레이 시스템
   - 재생/일시정지/정지
   - 속도 조절 (0.25x, 0.5x, 1x, 2x)
   - 타임라인 스크러빙
   - 특정 시점 일시정지 및 힘 벡터 분석

4. 다중 카메라 시스템
   - 포수 시점 (Catcher View)
   - 투수 시점 (Pitcher View)
   - 측면 시점 (Side View)
   - 공 추적 모드 (Ball Follow)
   - 자유 카메라 (OrbitControls)

5. 사용자 시스템
   - 회원가입/로그인 (JWT 인증)
   - 시뮬레이션 저장 (최대 10개)
   - URL 공유 (공유 토큰 생성)
   - 내 기록 관리

6. 미니게임 모드
   - 스트라이크 존 챌린지
   - 특정 구종 재현 챌린지
   - 최대 변화량 경쟁
   - 리더보드 (점수 순위)

7. 15개 파라미터 직접 입력 UI (프리셋 제거됨)
   - 공 물성: 질량, 반지름, 항력계수(C_d), 양력계수(C_L)
   - 투구 조건: 초기 속도, 발사각(수평/수직), 회전수(X/Y/Z축 rpm), 릴리스 포인트(X/Y/Z)
   - 환경 변수: 중력, 온도, 기압, 습도
   - 구종별 입력 예시 가이드 제공 (클릭하여 적용)
   - 투구 폼별 릴리스 포인트 예시 가이드 제공 (오버핸드/사이드암/언더핸드)

1.4 설계상 제약사항

1.4.1 성능 제약
- Intel 9세대 CPU에서 30fps 이상 유지 필수
- 초기 로딩 시간 < 3초 (Lighthouse 기준)
- 시뮬레이션 계산 시간 < 100ms
- **3D 에셋 단순화 방침**:
  - 3D 모델 폴리곤 수 < 300개 (최적화됨)
  - 야구공: 기본 구체 + 단순 텍스처
  - 야구장: 마운드/홈플레이트 마커만 표시
  - 그림자 품질: shadow-mapSize 1024 (2048→1024 감소)
- **렌더링 최적화**:
  - 목표 프레임레이트: 30fps (50fps에서 조정)
  - TrajectoryLine 포인트 간격 증가
  - React.memo 적용 (Ball3D, TrajectoryLine)
  - 궤적 라인: 단색 선으로 표현
  - **목적**: 교육용 물리 현상 시각화에 집중, 사실적 렌더링보다 명확한 움직임 강조
- 번들 크기 < 2MB (gzip)

1.4.2 기술 제약
-  물리 엔진 자체 개발 (하지만 확장 가능한 구조)
-  WebGL 1.0 최소 지원, WebGL 2.0 권장
-  프론트엔드 물리 계산 (Supabase는 데이터 저장만)
-  외부 물리 라이브러리는 Phase 2 (타격 시뮬레이션)에서 고려 가능

1.4.3 UI/UX 제약
- 세밀한 투수/포수 3D 모델 미구현 (간단한 실루엣만)
- 투구 폼 애니메이션 없음 (릴리즈 포인트만 설정 가능)
- 좌완/우완 구분 없음 (중앙에서 투구)

1.4.4 보안 제약
- HTTPS 필수 (프로덕션 환경)
- 비밀번호 bcrypt 암호화 (salt rounds: 10)
- JWT 토큰 만료 시간: 액세스 1시간, 리프레시 7일
- XSS/CSRF 방어 (헤더 설정, 입력 검증)

1.4.5 데이터 제약
- 사용자당 시뮬레이션 저장 최대 10개
- 리더보드 상위 100명만 표시
- 공유 URL 유효 기간: 30일

1.5 참조된 개발문서

| 문서명 | 파일명 | 설명 |
|--------|--------|------|
| 요구사항 명세서 | 요구사항명세서.hwp | FR-001 ~ FR-013 기능 요구사항 |

**프로젝트 정보**:
- 개발 기간: 2025년 9월 ~ 2025년 11월 (3개월)
- 개발 인원: 2명 (ㅇㅇㅎ, ㄱㅌㅎ)
- 개발 방법론: 애자일


2. 프로젝트 구조

2.1 프로젝트 시스템 구조 개요

본 프로젝트는 3-Tier 아키텍처 (프레젠테이션 계층 / 비즈니스 로직 계층 / 데이터 계층)를 기반으로 하며, 확장 가능한 모듈화 설계를 적용하였습니다.

핵심 설계 목표는 새로운 물리 시나리오 추가 시 코드 재사용률 80% 이상 달성입니다. 이를 위해 시나리오 간 공통 로직을 core 디렉토리에 구현하고, 시나리오별 차이점만 scenarios 디렉토리에 구현하는 구조를 채택했습니다.

2.1.1 시스템 계층 구조

[다이어그램 삽입: 시스템 3-Tier 아키텍처]
파일 위치: mermaid/1-architecture.mmd
설명: 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 계층으로 구성된 시스템 아키텍처를 표현합니다.
React 컴포넌트에서 SimulationContext를 거쳐 물리 엔진, 그리고 Supabase (Auth + Database)까지의 계층적 구조를 보여줍니다.

[다이어그램 삽입: 사용자 입력 데이터 흐름]
파일 위치: mermaid/7-data-flow.mmd
설명: 사용자 입력부터 시뮬레이션 결과까지의 데이터 변환 흐름을 표현합니다.
3단 구조(공 물성 파라미터, 투구 조건 파라미터, 환경 변수 파라미터)로 입력된 데이터가 어떻게 처리되어 최종 시뮬레이션 파라미터로 변환되는지 보여줍니다.


2.1.3 주요 아키텍처 패턴

| 패턴명 | 적용 위치 | 목적 |
|---|---|---|
| Template Method | BaseSimulator 추상 클래스 | 시뮬레이션 흐름 표준화, 공통 로직 재사용 |
| Factory | createSimulationContext() 함수 | 시나리오별 Context 자동 생성 |
| Strategy | eulerIntegrate() / rk4Integrate() | 수치 적분 알고리즘 교체 가능 |
| Observer | React Context API | 상태 변경 시 구독 컴포넌트 자동 업데이트 |

2.2 프로젝트 구조도

2.2.1 시스템 컨텍스트 다이어그램

[다이어그램 삽입: 시스템 컨텍스트 다이어그램]
파일 위치: mermaid/1-architecture.mmd
설명: 사용자, 웹 브라우저, 프론트엔드, Supabase (BaaS) 간의 상호작용을 표현합니다.

2.2.2 프론트엔드 디렉토리 구조

```
src/
├── core/                     # 재사용 가능한 공통 모듈
│   ├── physics/              # 물리 엔진
│   │   ├── integrator.ts     # 수치 적분 (Euler, RK4)
│   │   ├── forces.ts         # 힘 계산 함수
│   │   └── simulator.ts      # BaseSimulator 추상 클래스
│   ├── renderer/             # 3D 렌더링
│   │   ├── Scene3D.tsx       # Three.js 캔버스 설정
│   │   ├── Grid.tsx          # 격자 표시
│   │   ├── ForceVectors.tsx  # 힘 벡터 시각화
│   │   └── CameraController.tsx # 카메라 제어
│   └── ui/                   # 공통 UI 컴포넌트
│       ├── TopNavigationBar.tsx  # 상단 네비게이션 바
│       ├── TabContainer.tsx      # 재사용 가능한 탭 컨테이너
│       ├── HelpModal.tsx         # 도움말 모달
│       ├── RecentExperimentsPanel.tsx  # 최근 실험 패널
│       ├── ExperimentDetailModal.tsx   # 실험 상세 모달
│       ├── ResultPanel.tsx       # 결과 표시
│       ├── GenericInputPanel.tsx # 메타데이터 기반 입력
│       ├── ReplayControls.tsx    # 리플레이 시스템
│       └── ShareButton.tsx       # 공유 버튼
├── scenarios/                # 시나리오별 구현
│   └── pitch/                # 야구 투구 시뮬레이터
│       ├── presets.ts        # 9가지 구종 프리셋
│       ├── types.ts          # 투구 전용 타입
│       ├── Ball3D.tsx        # 야구공 3D 모델
│       ├── TrajectoryLine.tsx
│       ├── Field.tsx
│       └── PitchInputPanel.tsx
├── features/                 # 기능별 모듈
│   ├── auth/                 # 사용자 인증
│   │   ├── LoginForm.tsx
│   │   ├── RegisterForm.tsx
│   │   └── AuthContext.tsx
│   └── minigame/             # 미니게임
│       ├── StrikeZoneChallenge.tsx
│       ├── PitchMatchingChallenge.tsx
│       └── Leaderboard.tsx
├── contexts/
│   └── SimulationContext.tsx # 상태 관리
├── services/                 # API 클라이언트
│   ├── api.ts
│   ├── auth.service.ts
│   └── simulation.service.ts
├── types/
│   └── index.ts              # 글로벌 타입
└── App.tsx
```

2.2.3 Supabase 프로젝트 구조

본 프로젝트는 백엔드를 별도 서버로 구축하지 않고 Supabase BaaS(Backend as a Service)를 사용합니다.

Supabase 구성 요소:
- Auth: 회원가입/로그인, JWT 토큰 관리
- Database: PostgreSQL with Row Level Security (RLS)
- Realtime (예정): 리더보드 실시간 업데이트
- Storage (예정): 사용자 프로필 이미지

프론트엔드 Supabase 연동 구조:


src/
├── lib/
│   ├── supabase.ts               # Supabase 클라이언트 인스턴스
│   └── supabaseApi.ts            # API 레이어 (experimentsApi, minigameApi)
├── pages/
│   ├── LoginPage.tsx             # 로그인 페이지
│   ├── SignupPage.tsx            # 회원가입 페이지
│   └── PitchScenarioPage.tsx     # 시뮬레이션 페이지 (protected)
├── components/
│   └── ProtectedRoute.tsx        # 인증 가드
└── contexts/
    └── AuthContext.tsx           # (예정) 인증 상태 관리


데이터베이스 테이블:
- `auth.users`: Supabase Auth 기본 사용자 테이블
- `public.profiles`: 사용자 프로필 (username, role)
- `public.experiments`: 시뮬레이션 실험 저장 (params/result JSONB)
- `public.minigame_scores`: 미니게임 점수 (score JSONB)

RLS 정책:
모든 테이블에 `user_id = auth.uid()` 조건으로 사용자별 데이터 격리

2.3 자료 사전

2.3.1 물리 상수

| 상수명 | 값 | 단위 | 설명 |
|---|---|---|---|
| AIR_DENSITY_SEA_LEVEL | 1.225 | kg/m³ | 해수면 공기 밀도 |
| BASEBALL_MASS | 0.145 | kg | 야구공 질량 |
| BASEBALL_RADIUS | 0.0366 | m | 야구공 반지름 |
| DRAG_COEFFICIENT | 0.4 | - | 항력 계수 |
| LIFT_COEFFICIENT | 0.2 | - | 양력 계수 (마그누스) |
| MOUND_TO_PLATE | 18.44 | m | 투수판-홈플레이트 거리 |


3. 모듈 설계

3.1 물리 엔진 모듈

3.1.1 모듈 이름
BaseSimulator (추상 클래스)

3.1.2 모듈 형
클래스: abstract class BaseSimulator<TParams, TState, TResult>

제네릭 파라미터:
- TParams extends BaseSimulationParameters: 시뮬레이션 입력 파라미터
- TState extends BaseSimulationState: 시뮬레이션 상태
- TResult extends BaseSimulationResult: 시뮬레이션 결과

3.1.3 인터페이스

공개 메서드:
typescript
public simulate(): TResult

- 입력: 없음 (생성자에서 params 전달받음)
- 출력: TResult (시뮬레이션 결과 객체)
- 기능: 시뮬레이션 실행 및 결과 반환

보호 추상 메서드 (서브클래스에서 구현 필수):
typescript
protected abstract calculateForces(state: TState): Vector3
protected abstract shouldTerminate(state: TState): boolean
protected abstract createInitialState(): TState
protected abstract buildResult(trajectory: TState[], metadata: any): TResult


보호 메서드 (서브클래스에서 사용 가능):
typescript
protected integrate(
  state: TState,
  dt: number,
  method: 'euler' | 'rk4'
): TState


3.1.4 오류 메시지

| 오류 코드 | 메시지 | 발생 조건 |
|---|---|---|
| SIM_001 | "시뮬레이션 시간 초과 (> 10초)" | 무한 루프 방지 (10,000 타임스텝 초과) |
| SIM_002 | "초기 상태 생성 실패" | createInitialState() 반환값이 null |
| SIM_003 | "힘 계산 실패 (NaN 발생)" | calculateForces() 반환값에 NaN 포함 |

3.1.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| integrator.ts | 수치 적분 함수 (eulerIntegrate, rk4Integrate) |
| forces.ts | 힘 계산 함수 (calculateGravity, calculateDrag, calculateMagnus) |
| types-core-simulation.ts | Generic 타입 정의 |

3.1.6 호출하는 모듈

| 모듈명 | 호출 메서드 | 목적 |
|---|---|---|
| integrator | eulerIntegrate() | 1차 Euler 수치 적분 |
| integrator | rk4Integrate() | 4차 Runge-Kutta 수치 적분 |
| integrator | vectorAdd(), vectorMultiply() | 벡터 연산 |

3.1.7 기능 설명

설계 배경:
본 프로젝트는 야구 투구뿐만 아니라 포물선 운동, 진자 운동 등 다양한 물리 시나리오를 지원해야 합니다. 각 시나리오는 적용되는 물리 법칙(힘의 종류, 종료 조건)이 다르지만, 전체적인 시뮬레이션 흐름은 동일합니다.

해결 방안:
공통적인 시뮬레이션 알고리즘을 BaseSimulator 추상 클래스에 정의하고, 시나리오별로 달라지는 부분만 추상 메서드로 분리하였습니다. 이를 통해 새로운 시나리오 추가 시 전체 시뮬레이션 로직을 재작성할 필요 없이, 필요한 메서드만 구현하면 됩니다.

[다이어그램 삽입: 시뮬레이션 실행 시퀀스]
파일 위치: mermaid/2-simulation-sequence.mmd
설명: 사용자 입력부터 시뮬레이션 실행, 결과 표시까지의 전체 흐름을 시퀀스 다이어그램으로 표현합니다.
InputPanel → SimulationContext → PitchSimulator → Forces 모듈 → Integrator 모듈 간의 메서드 호출 순서를 보여줍니다.

구현 구조:

1. 공통 시뮬레이션 흐름 (모든 시나리오 동일):
   simulate() 메서드가 다음 순서로 실행됩니다.

   1) createInitialState() 호출 → 초기 상태 생성
   2) while (!shouldTerminate(state)):
        a) calculateForces(state) 호출 → 현재 힘 계산
        b) integrate(state, dt) 호출 → 다음 상태 계산
        c) trajectory에 state 기록
   3) buildResult(trajectory) 호출 → 결과 객체 생성
   4) return result

2. 시나리오별 구현 (서브클래스에서 정의):
   예시 - PitchSimulator의 경우:

   힘 계산 구현:
   protected calculateForces(state: PitchState): Vector3 {
     const gravity = calculateGravity(this.params.mass, this.params.environment.gravity)
     const drag = calculateDrag(state.velocity, this.params)
     const magnus = calculateMagnus(state.velocity, state.spin, this.params)
     return vectorAdd(vectorAdd(gravity, drag), magnus)
   }

   // 중력값은 환경 변수에서 가져옴 (9.78~9.83 m/s²)

   종료 조건 구현:
   protected shouldTerminate(state: PitchState): boolean {
     return state.position.z <= -MOUND_TO_PLATE || state.position.y < 0
   }

모듈 간 의존성:
BaseSimulator는 integrator.ts와 forces.ts 모듈을 사용하지만, Vector3 타입을 통해서만 데이터를 주고받습니다. 내부 구현이 변경되어도 인터페이스만 유지되면 상호 영향이 없습니다.

[다이어그램 삽입: 물리 계산 순서도]
파일 위치: mermaid/9-physics-flowchart.mmd
설명: 시뮬레이션 루프 내부의 물리 계산 과정을 순서도로 표현합니다.
초기 상태 설정 → 힘 계산(중력, 항력, 마그누스) → 수치 적분 → 궤적 기록 → 종료 조건 확인의 반복 흐름을 보여줍니다.

확장 가능성:
포물선 운동 시나리오를 추가할 경우, 약 30분 내에 구현 가능합니다. calculateForces()에서 마그누스 힘을 제거하고, shouldTerminate()를 y 좌표 기준으로 변경하면 됩니다.

성능 요구사항:
- 시뮬레이션 실행 시간: 100ms 미만 (1000 타임스텝 기준)
- 메모리 사용: 10MB 미만 (궤적 1000개 포인트 기준)


3.2 3D 렌더링 모듈

3.2.1 모듈 이름
ForceVectors (힘 벡터 시각화 컴포넌트)

3.2.2 모듈 형
React 함수형 컴포넌트 (Three.js ArrowHelper 사용)

3.2.3 인터페이스

Props:
typescript
interface ForceVectorsProps {
  position: Vector3           // 화살표 시작 위치 (공의 위치)
  forces: {
    gravity: Vector3          // 중력 벡터
    drag: Vector3             // 항력 벡터
    magnus: Vector3           // 마그누스 벡터
  }
  scale: number               // 화살표 크기 스케일 (기본값: 1.0)
  visible: boolean            // 표시 여부
}


출력: Three.js <arrowHelper> JSX 요소 3개

3.2.4 오류 메시지

| 오류 코드 | 메시지 | 발생 조건 |
|---|---|---|
| RENDER_001 | "벡터 크기가 0입니다" | 힘의 크기가 0이라 화살표 방향 결정 불가 |

3.2.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| @react-three/fiber | Three.js React 렌더러 |
| three | ArrowHelper 클래스 |

3.2.6 호출하는 모듈

없음 (Leaf 컴포넌트)

3.2.7 기능 설명

시각화 규칙:
- 중력: 파란색 (#0000ff), 항상 아래 방향
- 항력: 빨간색 (#ff0000), 속도 반대 방향
- 마그누스: 녹색 (#00ff00), ω × v 방향

화살표 크기:

arrowLength = vectorMagnitude * scale * 0.1  (m 단위)


예시:
- 중력 9.81 N, scale=1.0 → 화살표 길이 0.981m
- 항력 5.0 N, scale=2.0 → 화살표 길이 1.0m

렌더링 최적화:
- visible=false일 때 렌더링 스킵
- useMemo로 화살표 방향 캐싱


3.3 상태 관리 모듈

3.3.1 모듈 이름
createSimulationContext (Context Factory 함수)

3.3.2 모듈 형
함수: function createSimulationContext<TParams, TResult>(config)

3.3.3 인터페이스

입력:
typescript
interface ContextFactoryConfig<TParams, TResult> {
  defaultParams: TParams                                    // 기본 파라미터
  SimulatorClass: new (params: TParams) => ISimulator<TParams, TResult>
  presets?: Record<string, TParams>                         // 프리셋 목록 (선택)
}


출력:
typescript
{
  Provider: React.FC<{ children: ReactNode }>
  useSimulation: () => SimulationContextType<TParams, TResult>
}


3.3.4 오류 메시지

| 오류 코드 | 메시지 | 발생 조건 |
|---|---|---|
| CTX_001 | "Context Provider 외부에서 useSimulation 호출" | Provider 없이 훅 사용 |

3.3.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| react | createContext, useState, useContext |

3.3.6 호출하는 모듈

| 모듈명 | 호출 메서드 | 목적 |
|---|---|---|
| SimulatorClass (제네릭) | new SimulatorClass(params) | Simulator 인스턴스 생성 |
| SimulatorClass (제네릭) | simulator.simulate() | 시뮬레이션 실행 |

3.3.7 기능 설명

설계 배경:
각 시나리오(투구, 포물선, 진자)마다 독립적인 상태 관리가 필요합니다. React Context API를 사용하면 컴포넌트 간 상태 공유가 가능하지만, 시나리오마다 Context를 수동으로 작성하면 200줄 이상의 코드가 중복됩니다.

해결 방안:
createSimulationContext 팩토리 함수를 작성하여, 설정 객체만 전달하면 자동으로 Context와 Provider, 커스텀 훅을 생성하도록 했습니다. 이를 통해 코드 중복을 90% 이상 제거하고, 타입 안정성도 보장됩니다.

사용 예시:

투구 시나리오 Context 생성:
export const { Provider: PitchProvider, useSimulation: usePitchSimulation } =
  createSimulationContext({
    defaultParams: DEFAULT_PITCH_PARAMS,
    SimulatorClass: PitchSimulator,
    presets: PITCH_PRESETS
  })

포물선 운동 시나리오 Context 생성:
export const { Provider: ProjectileProvider, useSimulation: useProjectileSimulation } =
  createSimulationContext({
    defaultParams: DEFAULT_PROJECTILE_PARAMS,
    SimulatorClass: ProjectileSimulator
  })

재사용 효과:
위 두 시나리오의 Context 생성에 필요한 코드는 각각 5줄입니다. 만약 팩토리 함수 없이 직접 작성했다면 각 200줄씩 총 400줄이 필요했을 것입니다. 즉, 약 98%의 코드 중복을 제거했습니다.

제공 기능:
- setParams(params): 파라미터 변경
- setPreset(presetName): 프리셋 적용
- runSimulation(): 시뮬레이션 실행
- reset(): 초기화


3.4 UI 모듈

3.4.1 모듈 이름
GenericInputPanel (메타데이터 기반 자동 입력 UI)

3.4.2 모듈 형
React 함수형 컴포넌트

3.4.3 인터페이스

Props:
typescript
interface GenericInputPanelProps<TParams> {
  params: TParams                             // 현재 파라미터 값
  onChange: (params: TParams) => void         // 파라미터 변경 핸들러
  metadata: InputFieldMetadata[]              // 필드 메타데이터 배열
  presets?: Record<string, TParams>           // 프리셋 (선택)
  onPresetChange?: (presetName: string) => void
}

interface InputFieldMetadata {
  name: string                                // 필드 이름 (파라미터 키)
  label: string                               // 표시 라벨
  type: 'number' | 'slider' | 'select' | 'vector' | 'toggle'
  min?: number                                // 최소값 (number/slider)
  max?: number                                // 최대값 (number/slider)
  step?: number                               // 증감 단위
  unit?: string                               // 단위 표시 (예: "m/s")
  tooltip?: string                            // 도움말
  options?: { label: string, value: any }[]   // 선택지 (select)
  condition?: (params: TParams) => boolean    // 조건부 표시
}


3.4.4 오류 메시지

| 오류 코드 | 메시지 | 발생 조건 |
|---|---|---|
| UI_001 | "메타데이터의 name 필드가 params에 존재하지 않음" | 잘못된 메타데이터 |
| UI_002 | "유효성 검증 실패: 값이 min~max 범위 벗어남" | 사용자 입력 범위 오류 |

3.4.5 사용하는 파일

없음 (순수 React 컴포넌트)

3.4.6 호출하는 모듈

없음 (Leaf 컴포넌트)

3.4.7 기능 설명

설계 배경:
각 시나리오마다 입력 UI가 필요하지만, 파라미터 구조가 다릅니다. 투구는 3단 구조(공 물성, 투구 조건, 환경 변수)로 구성되며, 포물선은 5개 필드(초기 속도, 각도, 높이 등)를 가집니다. 시나리오마다 입력 폼을 따로 작성하면 비슷한 코드가 반복됩니다.

**파라미터 3단 구조** (야구 투구 시나리오):
1. **공 물성 파라미터**: 질량, 반지름, 항력계수(C_d), 양력계수(C_L)
2. **투구 조건 파라미터**: 초기 속도, 발사각(수평/수직), 회전수(X/Y/Z축 rpm), **릴리스 포인트(Vector3)**
3. **환경 변수 파라미터**: 중력(9.78~9.83 m/s²), 온도, 기압, 습도, 풍속/풍향
   → 환경 변수로부터 공기 밀도(ρ) 자동 계산

**릴리스 포인트 3D 좌표**:
- 기존 `releaseHeight` 제거 → `releasePoint: Vector3 { x, y, z }` 통합
- X축: 좌우 위치 (양수 = 1루 방향, 음수 = 3루 방향)
- Y축: 높이 (투구 폼별 릴리스 높이)
- Z축: 전후 위치 (마운드 기준)

**투구 폼별 릴리스 포인트 예시**:
```typescript
// 오버핸드 우완
{ x: 0.4, y: 2.0, z: 0 }

// 오버핸드 좌완
{ x: -0.4, y: 2.0, z: 0 }

// 사이드암 우완
{ x: 0.8, y: 1.2, z: 0 }

// 언더핸드 우완
{ x: 0.5, y: 0.8, z: 0 }

// 좌완 슬라이더 (바깥쪽 릴리스)
{ x: -0.6, y: 1.8, z: 0 }
```

**효과**:
- 우완/좌완 바깥쪽 릴리스로 실제 야구와 유사한 궤적 구현
- 마그누스 효과가 극적으로 체감되도록 개선
- UI: X/Y/Z축 입력 필드 + 투구 폼별 예시 가이드 버튼

해결 방안:
입력 필드의 메타데이터(이름, 타입, 범위, 단위 등)를 배열로 정의하면, 이를 기반으로 자동으로 UI를 생성하는 GenericInputPanel 컴포넌트를 구현했습니다. 이를 통해 시나리오별로 메타데이터만 정의하면 입력 UI가 자동 생성됩니다.

구현 방식:

1. 메타데이터 기반 컴포넌트 자동 생성:
   metadata 배열을 순회하며 각 필드 타입에 맞는 입력 컴포넌트를 렌더링합니다.
   - type: 'number' → 숫자 입력 필드
   - type: 'slider' → 슬라이더 + 현재 값 표시
   - type: 'select' → 드롭다운 선택
   - type: 'vector' → x, y, z 세 개의 숫자 입력 필드
   - type: 'toggle' → 체크박스

2. 조건부 필드 표시:
   condition 함수가 정의된 경우, 조건을 만족할 때만 필드를 표시합니다.
   예: 스핀 활성화 체크박스가 true일 때만 스핀 관련 필드 표시

3. 자동 유효성 검증:
   min, max 범위를 벗어나면 빨간색 테두리와 에러 메시지를 표시합니다.

재사용 효과:
- 투구 시나리오: 3단 구조별 메타데이터 정의만으로 입력 UI 완성
- 포물선 시나리오: 메타데이터 5개 정의만으로 입력 UI 완성
- 각 시나리오별 폼 컴포넌트를 따로 작성할 필요 없이 90% 코드 중복 제거

**환경 변수 → 공기 밀도 자동 계산**:
- 온도(T), 기압(p), 습도로부터 ρ = f(T, p, 습도) 계산
- 사용자에게 계산 과정 시각화하여 교육적 가치 제공

**공기 밀도 계산 공식**:
```typescript
// 1. 포화 수증기압 계산 (Tetens 공식)
const e_s = 6.1078 * Math.exp((17.27 * T) / (T + 237.3))  // hPa

// 2. 실제 수증기압 계산
const e = (humidity / 100) * e_s  // hPa

// 3. 건조 공기 분압 계산
const p_d = pressure - e  // hPa

// 4. 공기 밀도 계산 (이상기체 방정식)
const R_d = 287.05  // 건조공기 기체상수 (J/(kg·K))
const R_v = 461.495 // 수증기 기체상수 (J/(kg·K))
const T_K = T + 273.15  // 섭씨 → 켈빈
const rho = (p_d * 100) / (R_d * T_K) + (e * 100) / (R_v * T_K)  // kg/m³
```

**입력 범위**:
- 온도: -10°C ~ 40°C
- 기압: 950 ~ 1050 hPa
- 습도: 0% ~ 100%

**결과 범위**: ρ ≈ 1.1 ~ 1.3 kg/m³


3.4.6 TopNavigationBar (상단 네비게이션 바)

**모듈 이름**: TopNavigationBar

**모듈 형**: React 함수형 컴포넌트

**인터페이스**:
```typescript
interface TopNavigationBarProps {
  scenarioName?: string
  onBack?: () => void
  onHelpClick: () => void
}
```

**주요 기능**:
- 뒤로가기 버튼: 시나리오 선택 화면으로 이동 (라우터 구현 후)
- 시나리오 이름 표시: 현재 시나리오 식별
- 도움말 버튼: HelpModal 트리거
- 사용자 메뉴 버튼: 향후 확장 예정 (로그인/설정)

**사용하는 파일**:
| 파일명 | 용도 |
|--------|------|
| styled-components | 스타일링 |
| react | useState, MouseEventHandler |

**호출하는 모듈**:
| 모듈명 | 호출 시점 | 목적 |
|--------|----------|------|
| HelpModal | 도움말 버튼 클릭 시 | 사용자 가이드 표시 |

**기능 설명**:

UI 레이아웃:
- 48px 고정 높이
- 좌측 섹션: 뒤로가기 버튼(←) + 시나리오 이름
- 우측 섹션: 도움말 버튼(?) + 사용자 메뉴(👤)
- 전체 화면 상단 고정 배치 (z-index: 1000)

스타일링:
- 배경: #1a1a2e (다크 테마)
- 강조 색상: #4caf50 (녹색)
- 버튼 호버 효과: 배경 밝아짐


3.4.7 TabContainer (탭 컨테이너)

**모듈 이름**: TabContainer

**모듈 형**: React 함수형 컴포넌트 (재사용 가능)

**인터페이스**:
```typescript
export interface Tab {
  id: string
  label: string
  content: ReactNode
}

interface TabContainerProps {
  tabs: Tab[]
  defaultTab?: string
}
```

**주요 기능**:
- 탭 헤더 렌더링: 탭 목록을 수평 배열로 표시
- 활성 탭 콘텐츠 표시: 선택된 탭의 콘텐츠만 렌더링
- 탭 전환 애니메이션: 부드러운 전환 효과
- 스크롤 가능한 콘텐츠 영역: 콘텐츠가 길 경우 스크롤

**사용하는 파일**:
| 파일명 | 용도 |
|--------|------|
| styled-components | 스타일링 |
| react | useState, ReactNode |

**호출하는 모듈**:
없음 (Leaf 컴포넌트)

**기능 설명**:

사용 예시:
```typescript
const tabs: Tab[] = [
  { id: 'parameters', label: '파라미터', content: <PitchInputPanel /> },
  { id: 'results', label: '결과', content: <ResultPanel /> },
  { id: 'recent', label: '최근 실험', content: <RecentExperimentsPanel /> },
  { id: 'comparison', label: '비교', content: <ComparisonPanel /> }
]

<TabContainer tabs={tabs} defaultTab="parameters" />
```

UI 레이아웃:
- 탭 헤더: 상단 고정, 수평 배열
- 활성 탭 강조: 녹색 하단 보더
- 콘텐츠 영역: flex: 1, 스크롤 가능

재사용성:
- 다른 시나리오에서도 동일한 탭 구조 사용 가능
- Tab 인터페이스만 준수하면 모든 콘텐츠 호환


3.4.8 HelpModal (도움말 모달)

**모듈 이름**: HelpModal

**모듈 형**: React 함수형 컴포넌트

**인터페이스**:
```typescript
interface HelpModalProps {
  isOpen: boolean
  onClose: () => void
}
```

**주요 기능**:
- 3개 탭 구성: 시작하기 / 키보드 단축키 / FAQ
- **시작하기 탭**:
  - 1단계: 파라미터 입력 방법
  - 2단계: 시뮬레이션 실행
  - 3단계: 결과 확인 방법
- **키보드 단축키 탭**:
  - 시뮬레이션 제어: Space (실행/정지), R (초기화), Esc (정지)
  - 카메라 프리셋: 1 (포수), 2 (투수), 3 (측면), 4 (추적), 5 (자유)
  - 리플레이 제어: ←→ (프레임 이동), [] (속도 조절), ,. (0.1초 이동)
- **FAQ 탭**:
  - 스트라이크 존 정의 및 판정 기준
  - 회전축 (X/Y/Z) 효과 설명
  - 환경 변수 영향 설명
  - 비교 모드 사용법

**사용하는 파일**:
| 파일명 | 용도 |
|--------|------|
| styled-components | 스타일링 |
| react | useState |

**호출하는 모듈**:
없음 (Leaf 컴포넌트)

**기능 설명**:

UI 레이아웃:
- 중앙 정렬 모달 (최대 너비 800px)
- 오버레이 배경: rgba(0, 0, 0, 0.7), 클릭 시 닫기
- 모달 내부 탭 구조 (TabContainer 재사용)
- 스크롤 가능한 콘텐츠 (최대 높이 80vh)

접근성:
- ESC 키로 닫기
- 오버레이 클릭 시 닫기
- 모달 내부 클릭 시 이벤트 전파 차단


3.4.9 RecentExperimentsPanel (최근 실험 패널)

**모듈 이름**: RecentExperimentsPanel

**모듈 형**: React 함수형 컴포넌트

**인터페이스**:
```typescript
interface RecentExperimentsPanelProps {
  onLoad: (params: PitchParameters) => void
  onSave: (name: string) => void
}

interface RecentExperiment {
  id: string
  name: string
  params: PitchParameters
  result: SimulationResult
  createdAt: number
}
```

**주요 기능**:
- 실험 저장:
  - "현재 설정 저장" 버튼 클릭
  - 이름 지정 모달 표시 (기본값: "실험 MM-DD HH:mm")
  - LocalStorage에 저장
- 실험 불러오기:
  - "불러오기" 버튼 클릭
  - 파라미터 자동 복원
  - 원클릭으로 재실행 가능
- 실험 삭제:
  - 개별 삭제: "삭제" 버튼
  - 전체 삭제: "전체 삭제" 버튼 (확인 대화상자)
- 상세 보기:
  - "상세 보기" 버튼 클릭
  - ExperimentDetailModal 표시
- 실험 정보 표시:
  - 이름, 날짜
  - 속도, 회전 Y축, 스트라이크 판정 요약

**사용하는 파일**:
| 파일명 | 용도 |
|--------|------|
| @/utils/recentExperiments | recentExperimentsService (LocalStorage API) |
| styled-components | 스타일링 |
| react | useState, useEffect |

**호출하는 모듈**:
| 모듈명 | 호출 메서드 | 목적 |
|--------|------------|------|
| recentExperimentsService | getAll() | 실험 목록 조회 |
| recentExperimentsService | save() | 실험 저장 |
| recentExperimentsService | delete() | 실험 삭제 |
| ExperimentDetailModal | (렌더링) | 상세 정보 표시 |

**기능 설명**:

데이터 저장 방식:
- LocalStorage 키: `recentExperiments`
- 최대 10개 저장 (초과 시 가장 오래된 항목 자동 삭제)
- 데이터 구조: JSON 배열

UI 레이아웃:
- 헤더: 제목 "📋 최근 실험" + 카운트 (예: 7 / 10)
- 액션 버튼:
  - "💾 현재 설정 저장" (녹색)
  - "🗑️ 전체 삭제" (빨간색, 실험 있을 때만 표시)
- 실험 목록:
  - 스크롤 가능한 카드 리스트 (최대 높이 400px)
  - 각 카드: 이름, 날짜, 주요 파라미터, 액션 버튼 3개
  - 빈 상태: "📭 저장된 실험이 없습니다" 메시지

에러 처리:
- LocalStorage 접근 실패 시 콘솔 에러 출력
- 파싱 오류 시 빈 배열 반환


3.4.10 ExperimentDetailModal (실험 상세 모달)

**모듈 이름**: ExperimentDetailModal

**모듈 형**: React 함수형 컴포넌트

**인터페이스**:
```typescript
interface ExperimentDetailModalProps {
  experiment: RecentExperiment | null
  onClose: () => void
}
```

**주요 기능**:
- 실험 전체 정보 표시:
  - **공 물성 섹션**: 질량, 반지름, 항력계수, 양력계수
  - **투구 조건 섹션**:
    - 기본: 초기 속도, 수평 각도, 수직 각도
    - 회전: X축/Y축/Z축 rpm
    - 릴리스 포인트: X(좌우)/Y(높이)/Z(앞뒤)
  - **환경 변수 섹션**: 중력, 온도, 기압, 습도
  - **시뮬레이션 결과 섹션** (8가지 계측값):
    - 판정 (스트라이크/볼, 강조 표시)
    - 비행 시간, 최고 높이, 플레이트 높이
    - 수평 변화, 수직 낙차
    - 최종 속도, 궤적 포인트 개수

**사용하는 파일**:
| 파일명 | 용도 |
|--------|------|
| @/utils/recentExperiments | RecentExperiment 타입 |
| styled-components | 스타일링 |
| react | (기본 훅) |

**호출하는 모듈**:
없음 (Leaf 컴포넌트)

**기능 설명**:

UI 레이아웃:
- 중앙 정렬 모달 (최대 너비 700px, 최대 높이 90vh)
- 헤더: "📊 실험 상세 정보" + 닫기 버튼(×)
- 콘텐츠: 스크롤 가능
- 섹션별 구분: 녹색 좌측 보더
- 2열 그리드 레이아웃 (각 파라미터 표시)

스타일링:
- 스트라이크 판정: 녹색 배경 + 녹색 보더 강조
- 각 파라미터: 라벨(회색) + 값(흰색)
- 섹션 제목: 녹색 + 이모지


3.5 사용자 인증 모듈 (Supabase Auth)

3.5.1 모듈 이름
Supabase Authentication + LoginPage/SignupPage (프론트엔드)

3.5.2 모듈 형
- 백엔드: Supabase Auth (JWT 기반, 관리형 서비스)
- 프론트엔드: React 컴포넌트 (LoginPage.tsx, SignupPage.tsx, ProtectedRoute.tsx)

3.5.3 인터페이스

프론트엔드 컴포넌트:

// LoginPage.tsx
- 이메일, 비밀번호 입력 폼
- supabase.auth.signInWithPassword() 호출
- 로그인 성공 시 /pitch로 리디렉션

// SignupPage.tsx
- 이메일, 비밀번호, 사용자 이름, 역할(학생/교사) 입력
- supabase.auth.signUp() 호출
- metadata로 username, role 전달

// ProtectedRoute.tsx
- 로그인 확인: supabase.auth.getUser()
- 미로그인 시 /login으로 리디렉션
- 로그인 시 LocalStorage → Supabase 마이그레이션


Supabase Auth 트리거:

CREATE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, role)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', NEW.email),
    COALESCE(NEW.raw_user_meta_data->>'role', 'student')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;



3.5.4 오류 메시지

| 오류 코드 | 메시지 | HTTP 상태 |
|---|---|---|
| AUTH_001 | "이미 존재하는 이메일입니다" | 409 Conflict |
| AUTH_002 | "이메일 또는 비밀번호가 일치하지 않습니다" | 401 Unauthorized |
| AUTH_003 | "토큰이 만료되었습니다" | 401 Unauthorized |
| AUTH_004 | "유효하지 않은 토큰입니다" | 403 Forbidden |

3.5.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| bcrypt | 비밀번호 해싱/검증 |
| jsonwebtoken | JWT 생성/검증 |
| prisma/client | 데이터베이스 접근 |

3.5.6 호출하는 모듈

| 모듈명 | 호출 메서드 | 목적 |
|---|---|---|
| prisma.user | findUnique() | 사용자 조회 |
| prisma.user | create() | 신규 사용자 생성 |
| bcrypt | hash() | 비밀번호 해싱 (salt rounds: 10) |
| bcrypt | compare() | 비밀번호 검증 |
| jwt | sign() | 토큰 생성 (HS256 알고리즘) |
| jwt | verify() | 토큰 검증 |

3.5.7 기능 설명

[다이어그램 삽입: 사용자 인증 흐름]
파일 위치: mermaid/10-auth-flow.mmd
설명: 사용자 인증 프로세스를 시퀀스 다이어그램으로 표현합니다.
로그인 폼 → React App → Express API → JWT 생성 → Prisma → PostgreSQL까지의 전체 인증 흐름과 각 단계에서의 데이터 검증 과정을 보여줍니다.

회원가입 흐름:
1. 이메일 중복 확인 (prisma.user.findUnique)
2. 비밀번호 해싱 (bcrypt.hash, salt rounds: 10)
3. DB에 사용자 생성 (prisma.user.create)
4. 액세스 토큰 (1시간) + 리프레시 토큰 (7일) 생성

로그인 흐름:
1. 이메일로 사용자 조회
2. 비밀번호 검증 (bcrypt.compare)
3. JWT 토큰 쌍 생성 및 반환

토큰 구조:
json
{
  "userId": "uuid-string",
  "email": "user@example.com",
  "iat": 1234567890,
  "exp": 1234571490
}



3.6 데이터 저장 모듈

3.6.1 모듈 이름
supabaseApi (Supabase 클라이언트 API 레이어)

3.6.2 모듈 형
TypeScript 함수 집합 (Supabase JavaScript 클라이언트 기반)

3.6.3 인터페이스

Experiments API:

export const experimentsApi = {
  async list(limit?: number): Promise<ExperimentData[]>
  async create(name: string, params: PitchParameters, result: SimulationResult): Promise<string>
  async delete(id: string): Promise<void>
  async getMany(ids: string[]): Promise<ExperimentData[]>
}

interface ExperimentData {
  id: string
  user_id: string
  name: string
  params: PitchParameters    // JSONB
  result: SimulationResult   // JSONB
  created_at: string
}

Minigame API:

export const minigameApi = {
  async create(gameType: string, score: MinigameScore): Promise<string>
  async leaderboard(gameType: string, limit?: number): Promise<MinigameData[]>
}

interface MinigameScore {
  score: number
  accuracy: number
  timeElapsed: number
  // 게임별 추가 필드
}

Migration API:

export async function migrateLocalExperiments(): Promise<void>

3.6.4 오류 메시지

| 오류 코드 | 메시지 | 발생 조건 |
|---|---|---|
| SUPABASE_001 | "인증되지 않은 사용자입니다" | 로그인 필요 작업 시도 |
| SUPABASE_002 | "실험 조회 실패" | 데이터베이스 조회 오류 |
| SUPABASE_003 | "실험 저장 실패" | 데이터베이스 삽입 오류 |
| SUPABASE_004 | "권한이 없습니다" | RLS 정책 위반 (타 사용자 데이터 접근) |

3.6.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| @supabase/supabase-js | Supabase 클라이언트 |
| src/lib/supabase.ts | Supabase 클라이언트 인스턴스 |
| src/utils/recentExperiments.ts | LocalStorage 접근 |

3.6.6 호출하는 모듈

| 모듈명 | 호출 메서드 | 목적 |
|---|---|---|
| supabase | from('experiments').select() | 실험 목록 조회 |
| supabase | from('experiments').insert() | 실험 저장 |
| supabase | from('experiments').delete() | 실험 삭제 |
| supabase | from('minigame_scores').insert() | 미니게임 점수 저장 |
| supabase | from('minigame_scores').select() | 리더보드 조회 |
| supabase | auth.getUser() | 현재 사용자 정보 조회 |

3.6.7 기능 설명

설계 배경:
시나리오마다 파라미터 구조가 다릅니다. PitchParameters는 15개 필드를 가지지만, ProjectileParameters는 5개 필드만 가집니다. 각 시나리오마다 별도의 테이블을 만들면 테이블 수가 증가하고, 공통 로직 작성이 어렵습니다.

해결 방안:
Supabase PostgreSQL의 JSONB 타입을 활용하여 experiments 테이블의 params와 result 컬럼을 유연하게 설계합니다. 새로운 시나리오가 추가되어도 테이블 구조를 변경할 필요 없이 저장할 수 있습니다.

데이터베이스 스키마:

-- 사용자 프로필 테이블
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
  username TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'student',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 실험 저장 테이블
CREATE TABLE experiments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  name TEXT NOT NULL,
  params JSONB NOT NULL,
  result JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 미니게임 점수 테이블
CREATE TABLE minigame_scores (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  game_type TEXT NOT NULL,
  score JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

Row Level Security (RLS) 정책:
- 사용자는 자신의 데이터만 조회/삽입/삭제 가능
- 모든 테이블에 user_id = auth.uid() 조건 적용
- 익명 사용자 접근 불가 (로그인 필수)

LocalStorage 마이그레이션:
1. 첫 로그인 시 migrateLocalExperiments() 자동 호출
2. LocalStorage의 최근 실험 데이터 조회
3. Supabase experiments 테이블에 일괄 삽입
4. 마이그레이션 완료 후 LocalStorage 데이터 유지 (백업)

구현 상태:
- 완료: 테이블 생성 및 RLS 정책 적용
- 완료: Supabase API 레이어 구현 (experimentsApi, minigameApi)
- 완료: 로그인/회원가입 UI 구현
- 완료: ProtectedRoute 가드 구현
- 완료: LocalStorage 마이그레이션 로직 구현
- 미구현: 공유 기능 (향후 추가 예정)


3.7 리플레이 모듈

3.7.1 모듈 이름
ReplayControls (리플레이 제어 UI)

3.7.2 모듈 형
React 함수형 컴포넌트

3.7.3 인터페이스

Props:
typescript
interface ReplayControlsProps {
  trajectory: Vector3[]                     // 궤적 데이터
  onTimeChange: (time: number) => void      // 시간 변경 콜백
  playbackSpeed: number                     // 재생 속도 (0.25 ~ 2.0)
  onSpeedChange: (speed: number) => void    // 속도 변경 콜백
}


State (내부):
typescript
interface ReplayState {
  isPlaying: boolean
  currentTime: number        // 현재 재생 시간 (초)
  duration: number           // 전체 재생 시간 (초)
}


3.7.4 오류 메시지

없음 (UI 컴포넌트)

3.7.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| react | useState, useEffect, useRef |

3.7.6 호출하는 모듈

없음 (Leaf 컴포넌트)

3.7.7 기능 설명

재생 제어:
- 재생: requestAnimationFrame으로 매 프레임 currentTime 증가
- 일시정지: 애니메이션 중단
- 정지: currentTime = 0으로 리셋

속도 조절:
- 지원 속도: 0.25x, 0.5x, 1x, 2x
- 구현: deltaTime * playbackSpeed로 시간 증가량 조정

타임라인 스크러빙:
- <input type="range" min={0} max={duration} value={currentTime}>
- 드래그 시 즉시 해당 시점으로 이동

시각적 피드백:
- 재생 중: ▶ 아이콘 파란색
- 일시정지: ⏸ 아이콘 회색
- 진행 바: currentTime / duration * 100%


3.8 카메라 제어 모듈

3.8.1 모듈 이름
CameraController (카메라 프리셋 제어)

3.8.2 모듈 형
React 함수형 컴포넌트 (Three.js 카메라 제어)

3.8.3 인터페이스

Props:
typescript
interface CameraControllerProps {
  preset: CameraPreset
  targetPosition?: Vector3      // 카메라가 바라볼 위치 (선택)
}

type CameraPreset = 'catcher' | 'pitcher' | 'side' | 'follow' | 'free'


프리셋 정의:
typescript
const CAMERA_PRESETS: Record<CameraPreset, CameraConfig> = {
  catcher: { position: [-20, 1.5, 0], target: [0, 1.2, 0] },
  pitcher: { position: [2, 1.8, 0], target: [0, 1.2, -18] },
  side: { position: [0, 3, -9], target: [0, 1.2, -9] },
  follow: { position: 'dynamic', target: 'ball' },     // 공 위치 추적
  free: { position: 'user', target: 'user' }           // OrbitControls
}


3.8.4 오류 메시지

없음

3.8.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| @react-three/fiber | useThree, useFrame |
| @react-three/drei | OrbitControls |

3.8.6 호출하는 모듈

없음

3.8.7 기능 설명

프리셋 전환 애니메이션:
- 즉시 이동 대신 부드러운 전환 (Lerp 보간)
- 전환 시간: 1초

공 추적 모드 (follow):
- useFrame 훅으로 매 프레임 카메라 위치 업데이트
- 카메라 위치 = 공 위치 + offset [2, 2, 2]

자유 카메라 모드 (free):
- OrbitControls 활성화
- 마우스 드래그로 회전, 휠로 줌


3.8.8 카메라 프리셋 버튼 UI

**모듈 이름**: CameraPresetButtons

**모듈 형**: React 함수형 컴포넌트

**인터페이스**:
```typescript
interface CameraPresetButtonsProps {
  onPresetChange: (preset: CameraPreset) => void
  currentPreset: CameraPreset
}
```

**기능 설명**:
- 3가지 카메라 시점 전환 버튼 제공: 포수 시점, 측면, 투수 시점
- 현재 활성화된 프리셋 강조 표시
- 버튼 클릭 시 CameraController로 프리셋 전달

**UI 레이아웃**:
- 화면 우측 상단 고정 배치
- 버튼 3개 수평 배열
- 현재 선택된 버튼은 파란색 배경


3.8.9 리플레이 컨트롤 UI

**모듈 이름**: ReplayControls

**모듈 형**: React 함수형 컴포넌트

**인터페이스**:
```typescript
interface ReplayControlsProps {
  isPaused: boolean
  onPlayPause: () => void
  playbackSpeed: number
  onSpeedChange: (speed: number) => void
  progress: number              // 0~1
  onProgressChange: (progress: number) => void
  duration: number              // 시뮬레이션 전체 시간(초)
}
```

**기능 설명**:
- Play/Pause 버튼
- 속도 조절 버튼: 0.5x, 1x, 2x
- 진행률 슬라이더 (드래그하여 특정 시점 이동)
- 현재 시간 / 전체 시간 표시

**UI 레이아웃**:
- 화면 하단 중앙 배치
- Play/Pause 버튼 | 속도 버튼들 | 진행률 슬라이더
- 슬라이더 아래 시간 표시 (예: 1.2s / 3.5s)


3.9 미니게임 모듈

3.9.1 모듈 이름
minigame.service (미니게임 점수 관리)

3.9.2 모듈 형
TypeScript 클래스 (백엔드 서비스)

3.9.3 인터페이스

메서드:
typescript
class MinigameService {
  async submitScore(userId: string, gameType: string, score: number): Promise<void>
  async getLeaderboard(gameType: string, limit: number): Promise<LeaderboardEntry[]>
  async getMyRank(userId: string, gameType: string): Promise<{ rank: number, score: number }>
}

interface LeaderboardEntry {
  rank: number
  nickname: string
  score: number
  createdAt: Date
}


3.9.4 오류 메시지

| 오류 코드 | 메시지 | HTTP 상태 |
|---|---|---|
| GAME_001 | "유효하지 않은 게임 타입입니다" | 400 Bad Request |
| GAME_002 | "점수가 범위를 벗어났습니다" | 400 Bad Request |

3.9.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| prisma/client | 데이터베이스 접근 |

3.9.6 호출하는 모듈

| 모듈명 | 호출 메서드 | 목적 |
|---|---|---|
| prisma.leaderboard | create() | 점수 저장 |
| prisma.leaderboard | findMany() | 상위 100명 조회 |
| prisma.$queryRaw | SQL 쿼리 | 내 순위 계산 |

3.9.7 기능 설명

게임 타입:
- strike-zone: 스트라이크 존 명중률 (정확도 점수)
- pitch-matching: 특정 구종 재현도 (유사도 점수)
- max-break: 최대 변화량 경쟁 (거리 점수)

점수 계산 예시 (스트라이크 존):

score = (strikes / total_pitches) * 100
       + accuracy_bonus (홈플레이트 중앙에 가까울수록)


3.10 비교 모드 모듈3.10.1 모듈 이름ComparisonPanel + ComparisonContext (시뮬레이션 비교 기능)3.10.2 모듈 형React 함수형 컴포넌트 + Context API3.10.3 인터페이스**ComparisonContext:**typescriptinterface ComparisonContextValue {  experimentA: ComparisonExperiment | null  experimentB: ComparisonExperiment | null  isComparing: boolean  setExperimentA: (exp: ComparisonExperiment | null) => void  setExperimentB: (exp: ComparisonExperiment | null) => void  startComparison: () => void  stopComparison: () => void}interface ComparisonExperiment {  id: string  name: string  params: PitchParameters  result: SimulationResult}**ComparisonResultTable Props:**typescriptinterface ComparisonResultTableProps {  resultA: SimulationResult | null  resultB: SimulationResult | null  nameA: string  nameB: string}3.10.4 오류 메시지| 오류 코드 | 메시지 | 발생 조건 ||---|---|---|| CMP_001 | "저장된 실험이 없습니다. 먼저 실험을 저장하세요" | 저장 데이터 0개 || CMP_002 | "비교할 실험 2개를 선택하세요" | 선택 데이터 부족 |3.10.5 사용하는 파일| 파일명 | 용도 ||---|---|| src/contexts/ComparisonContext.tsx | 비교 상태 관리 || src/core/ui/ComparisonPanel.tsx | 비교 UI 패널 || src/core/ui/ComparisonResultTable.tsx | 결과 비교 테이블 || src/utils/supabaseExperiments.ts | Supabase 실험 조회 || src/scenarios/pitch/PitchSimulator.tsx | 궤적 렌더링 |3.10.6 호출하는 모듈| 모듈명 | 호출 메서드 | 목적 ||---|---|---|| supabaseExperimentsService | getAll(limit) | 실험 목록 조회 || ComparisonContext | setExperimentA/B() | 비교 대상 설정 || ComparisonContext | startComparison() | 비교 모드 시작 |3.10.7 기능 설명**설계 배경:**교육 현장에서 "파라미터 변화가 결과에 어떤 영향을 주는가?"를 직관적으로 학습하기 위해서는 2개 시뮬레이션을 동시에 비교할 수 있어야 합니다. 예를 들어, 스핀 속도만 다른 두 투구를 비교하면 마그누스 효과의 영향을 명확히 이해할 수 있습니다.**사용자 플로우:**1. 우측 패널에서 "비교" 탭 선택2. "실험 A" 드롭다운에서 첫 번째 실험 선택   - 속도, 회전, 스트라이크 판정 미리보기 표시3. "실험 B" 드롭다운에서 두 번째 실험 선택   - 속도, 회전, 스트라이크 판정 미리보기 표시4. "비교 시작" 버튼 클릭5. 3D 렌더링: 궤적A(파랑), 궤적B(빨강) 동시 표시6. 결과 비교 테이블 표시:   - 스트라이크 판정   - 비행 시간 (차이: ms)   - 최고 높이 (차이: cm)   - 수평 변화 (차이: cm)   - 수직 낙차 (차이: cm)   - 통과 높이 (차이: cm)7. "비교 종료" 버튼으로 일반 모드 복귀**3D 궤적 렌더링 구현:**typescript// PitchSimulator.tsxconst { experimentA, experimentB, isComparing } = useComparison(){isComparing ? (  <>    <TrajectoryLine points={experimentA.result.trajectory} color="#4444ff" />    <TrajectoryLine points={experimentB.result.trajectory} color="#ff4444" />  </>) : (  <TrajectoryLine points={currentResult.trajectory} color="#00ff00" />)}**결과 비교 테이블:**- 각 지표별로 실험A, 실험B 값 표시- 차이값(Δ) 오렌지색으로 강조- 스트라이크 판정은 체크/X 마크로 표시- 수치는 적절한 단위로 변환 (초, cm 등)**구현 상태:**- ✅ ComparisonContext 구현 완료- ✅ ComparisonPanel UI 구현 완료 (2개 선택 + 미리보기)- ✅ ComparisonResultTable 구현 완료 (6개 비교 지표)- ✅ 2개 궤적 동시 렌더링 구현 완료 (파랑/빨강)- ✅ 비교 시작/종료 버튼 구현 완료- ⏳ 환경 변수 통일 옵션 미구현 (향후 추가)- ⏳ 리플레이 동기화 미구현 (향후 추가)- ⏳ 시간별/거리별 필터 미구현 (향후 추가)**교육적 가치:**- 단일 변수 영향 분석 (예: 속도만 변경)- 회전 효과 비교 (예: 백스핀 vs 탑스핀)- 릴리스 포인트 영향 학습 (예: 오버핸드 vs 사이드암)

3.11 공유 기능 모듈

3.11.1 모듈 이름
ShareButton (공유 버튼 UI)

3.11.2 모듈 형
React 함수형 컴포넌트

3.11.3 인터페이스

Props:
typescript
interface ShareButtonProps {
  simulationId: string
  onShare?: (shareUrl: string) => void
}


3.10.4 오류 메시지

| 오류 코드 | 메시지 | 발생 조건 |
|---|---|---|
| SHARE_001 | "로그인이 필요합니다" | 비로그인 상태에서 공유 시도 |
| SHARE_002 | "공유 URL 생성 실패" | 백엔드 API 오류 |

3.10.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| axios | API 요청 |
| react-copy-to-clipboard | 클립보드 복사 |

3.10.6 호출하는 모듈

| 모듈명 | 호출 메서드 | 목적 |
|---|---|---|
| simulations.service (백엔드) | POST /api/simulations/:id/share | 공유 토큰 생성 |

3.10.7 기능 설명

공유 흐름:
1. 사용자가 "공유" 버튼 클릭
2. 백엔드 API 호출 (POST /api/simulations/:id/share)
3. shareToken 수신
4. 공유 URL 생성: https://domain.com/shared/{shareToken}
5. 클립보드에 자동 복사
6. "링크가 복사되었습니다!" 토스트 메시지 표시

공유 URL 접속 시:
- GET /api/simulations/shared/:token 호출
- 시뮬레이션 데이터 로드
- 읽기 전용 모드로 재생


3.12 성능 최적화 모듈

3.12.1 모듈 이름
PerformanceMonitor (성능 모니터링)

3.12.2 모듈 형
React 컴포넌트 + 유틸리티 함수

3.12.3 인터페이스

Props:
typescript
interface PerformanceMonitorProps {
  onFpsDrop: (fps: number) => void          // FPS 30 이하 시 콜백
}


유틸리티:
typescript
function measureSimulationTime(fn: () => void): number  // 밀리초 반환


3.12.4 오류 메시지

없음 (모니터링만 수행)

3.12.5 사용하는 파일

| 파일명 | 용도 |
|---|---|
| stats.js | FPS 측정 |

3.12.6 호출하는 모듈

없음

3.12.7 기능 설명

FPS 모니터링:
- stats.js 라이브러리 사용
- 1초마다 평균 FPS 계산
- FPS < 30 시 onFpsDrop 콜백 실행 → LOD 레벨 자동 조정

최적화 전략:
1. Code Splitting: React.lazy + Suspense
2. Memoization: React.memo, useMemo, useCallback
3. LOD (Level of Detail):
   - 거리 < 5m: 구체 세그먼트 32
   - 거리 5~15m: 구체 세그먼트 16
   - 거리 > 15m: 구체 세그먼트 8
4. 객체 풀링: 궤적 포인트 재사용 (GC 부담 감소)


3.13 에러 처리 모듈

3.13.1 모듈 이름
errorHandler (전역 에러 핸들러 미들웨어)

3.13.2 모듈 형
Express.js 미들웨어 함수

3.13.3 인터페이스

typescript
function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void


3.13.4 오류 메시지

표준 에러 응답 형식:
json
{
  "error": {
    "code": "AUTH_002",
    "message": "이메일 또는 비밀번호가 일치하지 않습니다",
    "statusCode": 401
  }
}


3.13.5 사용하는 파일

없음

3.13.6 호출하는 모듈

없음 (모든 라우트에서 자동 호출)

3.13.7 기능 설명

에러 분류:
1. Validation Error (400): Zod 스키마 검증 실패
2. Authentication Error (401): 토큰 없음/만료
3. Authorization Error (403): 권한 부족
4. Not Found Error (404): 리소스 없음
5. Internal Server Error (500): 예상치 못한 오류

프로덕션 환경:
- 스택 트레이스 숨김 (보안)
- 에러 로그 파일 저장 (logs/error.log)

개발 환경:
- 스택 트레이스 포함
- 콘솔에 에러 출력


4. 파일 구조 및 데이터베이스(DB) 설계

4.1 외부 파일(데이터베이스)의 논리적 구조

4.1.1 ERD (Entity Relationship Diagram)

[다이어그램 삽입: 데이터베이스 ERD]
파일 위치: mermaid/3-erd.mmd
설명: User, Simulation, Leaderboard 테이블 간의 관계를 표현합니다.
User는 Simulation과 Leaderboard를 소유하는 1:N 관계입니다.

4.1.2 테이블 상세 설계

User 테이블

설계 의도:
사용자 인증 및 개인화 기능을 제공하기 위한 테이블입니다. 비밀번호는 평문 저장 없이 bcrypt 해싱하여 보안을 강화하고, 닉네임으로 리더보드에서 식별 가능하도록 설계했습니다.

| 컬럼명 | 타입 | 제약 조건 | 설명 |
|---|---|---|---|
| id | UUID | PRIMARY KEY | 사용자 고유 ID |
| email | VARCHAR(255) | UNIQUE, NOT NULL | 이메일 (로그인 ID) |
| passwordHash | VARCHAR(255) | NOT NULL | bcrypt 해시 (salt rounds: 10) |
| nickname | VARCHAR(50) | NOT NULL | 닉네임 (리더보드 표시용) |
| createdAt | TIMESTAMP | NOT NULL, DEFAULT NOW() | 가입 일시 |

인덱스:
- idx_user_email: email (UNIQUE)
  이유: 로그인 시 이메일로 조회하므로 조회 성능 최적화

Simulation 테이블

설계 의도:
다양한 물리 시나리오(투구, 포물선, 진자 등)의 데이터를 단일 테이블에 저장하기 위해 유연한 스키마를 채택했습니다. JSONB 타입을 사용하여 시나리오마다 다른 파라미터 구조를 지원하며, 새로운 시나리오 추가 시 테이블 변경 없이 확장 가능합니다.

| 컬럼명 | 타입 | 제약 조건 | 설명 |
|---|---|---|---|
| id | UUID | PRIMARY KEY | 시뮬레이션 고유 ID |
| userId | UUID | FOREIGN KEY (User.id) | 소유자 |
| scenarioType | VARCHAR(50) | NOT NULL | 시나리오 타입 ('pitch', 'projectile' 등) |
| parameters | JSONB | NOT NULL | 입력 파라미터 (시나리오별 구조 상이) |
| result | JSONB | NOT NULL | 시뮬레이션 결과 (시나리오별 구조 상이) |
| shareToken | VARCHAR(64) | UNIQUE | 공유 토큰 (NULL 가능) |
| shareExpiresAt | TIMESTAMP | NULL | 공유 만료 일시 |
| createdAt | TIMESTAMP | NOT NULL, DEFAULT NOW() | 생성 일시 |

JSONB 컬럼 사용 이유:
- parameters: 투구는 15개 필드, 포물선은 5개 필드 등 시나리오마다 구조가 다름
- result: 각 시나리오마다 산출되는 결과 데이터 구조가 상이함
- PostgreSQL JSONB는 인덱싱 가능하고 쿼리 성능이 우수하여 선택

인덱스:
- idx_simulation_userId: userId
  이유: 사용자별 시뮬레이션 목록 조회 시 성능 최적화
- idx_simulation_shareToken: shareToken (UNIQUE)
  이유: 공유 URL 접근 시 빠른 조회

제약 조건:
- 사용자당 최대 10개 제한 (애플리케이션 레벨에서 체크)
  이유: 데이터베이스 스토리지 비용 절감

Leaderboard 테이블

설계 의도:
미니게임 모드의 점수와 순위를 관리하기 위한 테이블입니다. 게임 타입별로 상위 100명만 표시하도록 설계되었으며, 빠른 순위 조회를 위해 (gameType, score DESC) 복합 인덱스를 적용했습니다.

| 컬럼명 | 타입 | 제약 조건 | 설명 |
|---|---|---|---|
| id | UUID | PRIMARY KEY | 기록 고유 ID |
| userId | UUID | FOREIGN KEY (User.id) | 사용자 |
| gameType | VARCHAR(50) | NOT NULL | 게임 타입 ('strike-zone', 'pitch-matching' 등) |
| score | INTEGER | NOT NULL | 점수 |
| createdAt | TIMESTAMP | NOT NULL, DEFAULT NOW() | 기록 일시 |

인덱스:
- idx_leaderboard_gameType_score: (gameType, score DESC) - 순위 조회 최적화
- idx_leaderboard_userId: userId

4.2 공유 자료

4.2.1 글로벌 타입 정의

파일: src/types/index.ts

typescript
// 모든 모듈에서 공유되는 타입
export interface Vector3 {
  x: number
  y: number
  z: number
}

export const PHYSICS_CONSTANTS = {
  AIR_DENSITY_SEA_LEVEL: 1.225,     // kg/m³ (참조값, 환경 조건으로 자동 계산)
  BASEBALL_MASS: 0.145,             // kg (기본값, 사용자 조정 가능)
  BASEBALL_RADIUS: 0.0366,          // m (기본값, 사용자 조정 가능)
  DRAG_COEFFICIENT: 0.4,            // 기본값, 사용자 조정 가능
  LIFT_COEFFICIENT: 0.2,            // 기본값, 사용자 조정 가능
  MOUND_TO_PLATE: 18.44             // m
}

// UI 모드는 단일 모드로 통합 (이전 Simple/Advanced 모드 제거)


4.2.2 환경 변수

파일: .env (프론트엔드)


VITE_API_BASE_URL=http://localhost:4000
VITE_ENABLE_ANALYTICS=false


파일: .env (백엔드)


DATABASE_URL=postgresql://user:password@localhost:5432/physics_simulator
JWT_SECRET=your-secret-key-here
JWT_ACCESS_EXPIRY=1h
JWT_REFRESH_EXPIRY=7d
PORT=4000


4.3 파일 접근 방법(데이터베이스 관리체계; DBMS)

4.3.1 DBMS 선정

- DBMS: PostgreSQL 16.x
- 선정 이유:
  1. JSONB 타입 지원 (유연한 스키마)
  2. 복잡한 쿼리 성능 우수
  3. 오픈소스, 무료
  4. Prisma ORM 완벽 지원

4.3.2 ORM (Prisma)

Prisma Schema 파일: server/prisma/schema.prisma

prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id           String        @id @default(uuid())
  email        String        @unique
  passwordHash String
  nickname     String
  createdAt    DateTime      @default(now())
  simulations  Simulation[]
  leaderboard  Leaderboard[]
}

model Simulation {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  scenarioType    String
  parameters      Json
  result          Json
  shareToken      String?   @unique
  shareExpiresAt  DateTime?
  createdAt       DateTime  @default(now())

  @@index([userId])
  @@index([shareToken])
}

model Leaderboard {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  gameType  String
  score     Int
  createdAt DateTime @default(now())

  @@index([gameType, score(sort: Desc)])
  @@index([userId])
}


4.3.3 데이터베이스 접근 패턴

1) 연결 풀링:
typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  },
  log: ['query', 'error', 'warn']  // 개발 환경
})

export default prisma


2) 쿼리 예시:

typescript
// 사용자 시뮬레이션 목록 조회 (최신 10개)
const simulations = await prisma.simulation.findMany({
  where: { userId },
  orderBy: { createdAt: 'desc' },
  take: 10
})

// 리더보드 상위 100명 조회
const leaderboard = await prisma.leaderboard.findMany({
  where: { gameType },
  orderBy: { score: 'desc' },
  take: 100,
  include: {
    user: {
      select: { nickname: true }
    }
  }
})

// 내 순위 계산 (Raw SQL)
const [{ rank }] = await prisma.$queryRaw`
  SELECT COUNT(*) + 1 AS rank
  FROM "Leaderboard"
  WHERE "gameType" = ${gameType}
    AND "score" > (
      SELECT "score" FROM "Leaderboard"
      WHERE "userId" = ${userId} AND "gameType" = ${gameType}
      ORDER BY "createdAt" DESC LIMIT 1
    )
`



4.3.4 트랜잭션 처리

typescript
// 시뮬레이션 저장 + 오래된 것 삭제 (원자적 처리)
await prisma.$transaction(async (tx) => {
  // 1. 현재 저장된 개수 확인
  const count = await tx.simulation.count({ where: { userId } })

  // 2. 10개 초과 시 가장 오래된 것 삭제
  if (count >= 10) {
    const oldest = await tx.simulation.findFirst({
      where: { userId },
      orderBy: { createdAt: 'asc' }
    })
    await tx.simulation.delete({ where: { id: oldest.id } })
  }

  // 3. 새 시뮬레이션 저장
  await tx.simulation.create({ data: simulationData })
})



5. 요구 분석 참조표

| 요구사항 ID | 요구사항 명칭 | 관련 모듈 | 구현 상태 | 비고 |
| FR-001 | 단순 모드 시뮬레이션 | GenericInputPanel, PitchSimulator |  완료 | 1-10 슬라이더 + 구종 선택 |
| FR-002 | 전문가 모드 파라미터 조정 | GenericInputPanel (메타데이터 확장) |  완료 | 15개 파라미터 세밀 조정 |
| FR-003 | 물리 계산 엔진 | BaseSimulator, Forces, Integrator |  완료 | Euler + RK4 지원 |
| FR-004 | 3D 시각화 | Scene3D, Ball3D, TrajectoryLine |  완료 | Three.js r170 |
| FR-005 | 결과 분석 | ResultPanel |  완료 | 비행시간, 높이, 스트라이크 판정 |
| FR-006 | 물리력 벡터 시각화 | ForceVectors |  완료 | 중력/항력/마그누스 화살표 |
| FR-007 | 리플레이 및 슬로우 모션 | ReplayControls |  완료 | 0.25x ~ 2x 속도 조절 |
| FR-008 | 다중 카메라 앵글 | CameraController |  완료 | 5가지 프리셋 |
| FR-009 | 사용자 계정 시스템 | auth.service, auth.middleware |  완료 | JWT 인증 |
| FR-010 | 시뮬레이션 저장 및 공유 | simulations.service, ShareButton |  완료 | 최대 10개, 공유 URL |
| FR-011 | 미니게임 모드 | minigame.service |  완료 | 3가지 게임 타입 |
| FR-012 | 리더보드 및 랭킹 | leaderboard 테이블 |  완료 | 상위 100명 표시 |
| FR-013 | 확장 가능한 아키텍처 시스템 | BaseSimulator, createSimulationContext, GenericInputPanel |  완료 | 코드 재사용률 80% 달성 |


6. 제약사항

6.1 성능 제약사항

| 항목 | 제약 조건 | 측정 방법 |
| 프레임레이트 | 30fps 이상 (Intel 9세대 CPU) | Chrome DevTools Performance 탭 |
| 시뮬레이션 계산 시간 | < 100ms | performance.now() 측정 |
| 초기 로딩 시간 | < 3초 | Lighthouse Performance 점수 |
| 번들 크기 | < 2MB (gzip) | Vite 빌드 결과 확인 |
| 메모리 사용 | < 50MB (프론트엔드) | Chrome Task Manager |

6.2 기술 제약사항

| 항목 | 제약 조건 | 사유 |
| 브라우저 | Chrome 90+, Firefox 88+, Safari 14+ | WebGL 2.0 지원 필요 |
| Node.js | 20.x LTS 이상 | ES Modules, Top-level await 사용 |
| PostgreSQL | 16.x 이상 | JSONB 성능 최적화 |
| TypeScript | 5.x strict mode | 타입 안정성 보장 |

6.3 비즈니스 제약사항

| 항목 | 제약 조건 | 사유 |
| 저장 한도 | 사용자당 시뮬레이션 10개 | 데이터베이스 비용 절감 |
| 공유 기한 | 공유 URL 30일 | 스토리지 관리 |
| 리더보드 | 상위 100명만 표시 | 성능 및 UX 고려 |

6.4 보안 제약사항

| 항목 | 제약 조건 | 구현 방법 |
| HTTPS | 프로덕션 환경 필수 | Let's Encrypt SSL 인증서 |
| 비밀번호 | bcrypt salt rounds: 10 | bcrypt.hash() |
| JWT 만료 | 액세스 1시간, 리프레시 7일 | jwt.sign({ expiresIn }) |
| CORS | 화이트리스트 기반 | Express CORS 미들웨어 |


7. 참고 사항

7.1 핵심 설계 의사결정 요약

본 프로젝트의 핵심 설계 결정 사항과 그 이유를 요약합니다.

1. 공통 로직 추출 및 재사용 (BaseSimulator 추상 클래스)

의사결정 배경:
야구 투구, 포물선 운동, 진자 운동 등 다양한 물리 시나리오를 지원해야 하며, 각 시나리오는 물리 법칙은 다르지만 시뮬레이션 흐름은 동일합니다.

채택한 방안:
공통 알고리즘을 BaseSimulator에 구현하고, 시나리오별 차이(힘 계산, 종료 조건)만 추상 메서드로 분리했습니다.

효과:
- 새 시나리오 추가 시 개발 시간 2일에서 30분으로 단축 (92% 감소)
- 코드 재사용률 80% 달성

2. 자동 생성 패턴 (createSimulationContext 팩토리)

의사결정 배경:
각 시나리오마다 React Context를 수동으로 작성하면 200줄 이상의 유사 코드가 반복됩니다.

채택한 방안:
설정 객체만 전달하면 Context, Provider, 커스텀 훅을 자동 생성하는 팩토리 함수를 구현했습니다.

효과:
- Context 생성 코드 200줄에서 5줄로 단축 (98% 감소)
- 타입 안전성 자동 보장

3. 유연한 데이터 스키마 (JSONB 컬럼)

의사결정 배경:
시나리오마다 파라미터 구조가 다르므로, 시나리오별 테이블을 만들면 테이블 수가 증가하고 공통 로직 작성이 어렵습니다.

채택한 방안:
Simulation 테이블의 parameters와 result를 JSONB 타입으로 정의하여 유연한 스키마를 지원했습니다.

효과:
- 새 시나리오 추가 시 데이터베이스 마이그레이션 불필요
- 단일 테이블로 모든 시나리오 데이터 관리 가능

4. 메타데이터 기반 UI 생성 (GenericInputPanel)

의사결정 배경:
시나리오마다 입력 폼을 따로 작성하면 유사한 코드가 반복됩니다.

채택한 방안:
필드 메타데이터(이름, 타입, 범위 등)를 정의하면 자동으로 UI를 생성하는 범용 컴포넌트를 구현했습니다.

효과:
- 입력 폼 코드 중복 90% 제거
- 새 시나리오의 입력 UI를 메타데이터 정의만으로 구현 가능

7.2 확장 시나리오 예시

포물선 운동 추가:

1. 타입 정의 :
   typescript
   interface ProjectileParameters extends BaseSimulationParameters {
     initialSpeed: number
     angle: number
     height: number
   }
   

2. Simulator 구현 :
   typescript
   class ProjectileSimulator extends BaseSimulator<...> {
     calculateForces(state) {
       return vectorAdd(calculateGravity(...), calculateDrag(...))
     }
     shouldTerminate(state) {
       return state.position.y <= 0
     }
   }
   

3. Context 생성:
   typescript
   export const { Provider, useSimulation } = createSimulationContext({
     defaultParams: DEFAULT_PROJECTILE_PARAMS,
     SimulatorClass: ProjectileSimulator
   })
   
7.3 배포 전략

프론트엔드:
- 플랫폼: Vercel
- 빌드 명령: npm run build
- 환경 변수: VITE_API_BASE_URL (프로덕션 API URL)

백엔드:
- 플랫폼: Railway / Render
- 데이터베이스: Railway PostgreSQL
- 환경 변수: DATABASE_URL, JWT_SECRET

CI/CD:
- GitHub Actions를 통한 자동 배포
- main 브랜치 push 시 자동 빌드 및 배포